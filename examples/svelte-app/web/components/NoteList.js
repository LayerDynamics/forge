/* NoteList.svelte generated by Svelte v4.2.20 */
import {
	SvelteComponent,
	append,
	append_styles,
	attr,
	destroy_block,
	detach,
	element,
	ensure_array_like,
	init,
	insert,
	listen,
	noop,
	safe_not_equal,
	set_data,
	space,
	svg_element,
	text,
	toggle_class,
	update_keyed_each
} from "svelte/internal";

import "svelte/internal/disclose-version";
import { createEventDispatcher } from 'svelte';

function add_css(target) {
	append_styles(target, "svelte-1pysysm", ".note-list.svelte-1pysysm{width:300px;height:100%;display:flex;flex-direction:column;background-color:var(--bg-primary);border-right:1px solid var(--border-color);flex-shrink:0}.list-header.svelte-1pysysm{padding:var(--spacing-md);border-bottom:1px solid var(--border-color)}.search-wrapper.svelte-1pysysm{position:relative;margin-bottom:var(--spacing-sm)}.search-icon.svelte-1pysysm{position:absolute;left:var(--spacing-md);top:50%;transform:translateY(-50%);color:var(--text-muted);pointer-events:none}.search-input.svelte-1pysysm{width:100%;padding:var(--spacing-sm) var(--spacing-md);padding-left:40px;padding-right:36px;font-size:14px;color:var(--text-primary);background-color:var(--bg-secondary);border:1px solid var(--border-color);border-radius:var(--radius-md);outline:none;transition:all var(--transition-fast)}.search-input.svelte-1pysysm:focus{border-color:var(--accent-primary);box-shadow:0 0 0 3px var(--accent-light)}.search-input.svelte-1pysysm::placeholder{color:var(--text-muted)}.search-clear.svelte-1pysysm{position:absolute;right:var(--spacing-sm);top:50%;transform:translateY(-50%);background:none;border:none;color:var(--text-muted);cursor:pointer;padding:var(--spacing-xs);border-radius:var(--radius-sm)}.search-clear.svelte-1pysysm:hover{color:var(--text-primary);background-color:var(--bg-hover)}.list-count.svelte-1pysysm{font-size:12px;color:var(--text-muted)}.list-content.svelte-1pysysm{flex:1;overflow-y:auto;padding:var(--spacing-sm)}.notes.svelte-1pysysm{list-style:none}.note-card.svelte-1pysysm{width:100%;padding:var(--spacing-md);margin-bottom:var(--spacing-sm);background-color:var(--bg-secondary);border:1px solid var(--border-color);border-radius:var(--radius-md);cursor:pointer;text-align:left;transition:all var(--transition-fast)}.note-card.svelte-1pysysm:hover{background-color:var(--bg-hover);border-color:var(--border-light)}.note-card.selected.svelte-1pysysm{background-color:var(--accent-light);border-color:var(--accent-primary)}.note-header.svelte-1pysysm{display:flex;align-items:flex-start;justify-content:space-between;gap:var(--spacing-sm);margin-bottom:var(--spacing-sm)}.note-title.svelte-1pysysm{font-size:14px;font-weight:500;color:var(--text-primary);flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.note-preview.svelte-1pysysm{font-size:12px;color:var(--text-secondary);line-height:1.4;margin-bottom:var(--spacing-sm);display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden}.note-meta.svelte-1pysysm{display:flex;align-items:center;justify-content:space-between}.note-date.svelte-1pysysm{font-size:11px;color:var(--text-muted)}.empty-state.svelte-1pysysm{padding:var(--spacing-xl)}");
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

// (60:6) {#if searchQuery}
function create_if_block_3(ctx) {
	let button;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			button.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
			attr(button, "class", "search-clear svelte-1pysysm");
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler*/ ctx[7]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			mounted = false;
			dispose();
		}
	};
}

// (92:4) {:else}
function create_else_block_2(ctx) {
	let ul;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_value = ensure_array_like(/*notes*/ ctx[0]);
	const get_key = ctx => /*note*/ ctx[9].id;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(ul, "class", "notes svelte-1pysysm");
		},
		m(target, anchor) {
			insert(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(ul, null);
				}
			}
		},
		p(ctx, dirty) {
			if (dirty & /*selectedNoteId, notes, selectNote, formatDate, truncateContent, categoryColors*/ 83) {
				each_value = ensure_array_like(/*notes*/ ctx[0]);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, destroy_block, create_each_block, null, get_each_context);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(ul);
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};
}

// (75:4) {#if notes.length === 0}
function create_if_block(ctx) {
	let div1;
	let div0;
	let t;
	let p;

	function select_block_type_1(ctx, dirty) {
		if (/*searchQuery*/ ctx[2]) return create_if_block_2;
		return create_else_block_1;
	}

	let current_block_type = select_block_type_1(ctx, -1);
	let if_block0 = current_block_type(ctx);

	function select_block_type_2(ctx, dirty) {
		if (/*searchQuery*/ ctx[2]) return create_if_block_1;
		return create_else_block;
	}

	let current_block_type_1 = select_block_type_2(ctx, -1);
	let if_block1 = current_block_type_1(ctx);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if_block0.c();
			t = space();
			p = element("p");
			if_block1.c();
			attr(div0, "class", "empty-state-icon");
			attr(div1, "class", "empty-state svelte-1pysysm");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			if_block0.m(div0, null);
			append(div1, t);
			append(div1, p);
			if_block1.m(p, null);
		},
		p(ctx, dirty) {
			if (current_block_type !== (current_block_type = select_block_type_1(ctx, dirty))) {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div0, null);
				}
			}

			if (current_block_type_1 === (current_block_type_1 = select_block_type_2(ctx, dirty)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type_1(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(p, null);
				}
			}
		},
		d(detaching) {
			if (detaching) {
				detach(div1);
			}

			if_block0.d();
			if_block1.d();
		}
	};
}

// (94:8) {#each notes as note (note.id)}
function create_each_block(key_1, ctx) {
	let li;
	let button;
	let div0;
	let h4;
	let t0_value = (/*note*/ ctx[9].title || 'Untitled') + "";
	let t0;
	let t1;
	let span0;
	let t2_value = /*note*/ ctx[9].category + "";
	let t2;
	let span0_class_value;
	let t3;
	let p;
	let t4_value = (truncateContent(/*note*/ ctx[9].content) || 'No content') + "";
	let t4;
	let t5;
	let div1;
	let span1;
	let t6_value = formatDate(/*note*/ ctx[9].modifiedAt) + "";
	let t6;
	let t7;
	let mounted;
	let dispose;

	function click_handler_1() {
		return /*click_handler_1*/ ctx[8](/*note*/ ctx[9]);
	}

	return {
		key: key_1,
		first: null,
		c() {
			li = element("li");
			button = element("button");
			div0 = element("div");
			h4 = element("h4");
			t0 = text(t0_value);
			t1 = space();
			span0 = element("span");
			t2 = text(t2_value);
			t3 = space();
			p = element("p");
			t4 = text(t4_value);
			t5 = space();
			div1 = element("div");
			span1 = element("span");
			t6 = text(t6_value);
			t7 = space();
			attr(h4, "class", "note-title svelte-1pysysm");
			attr(span0, "class", span0_class_value = "badge " + (/*categoryColors*/ ctx[4][/*note*/ ctx[9].category] || 'badge-other') + " svelte-1pysysm");
			attr(div0, "class", "note-header svelte-1pysysm");
			attr(p, "class", "note-preview svelte-1pysysm");
			attr(span1, "class", "note-date svelte-1pysysm");
			attr(div1, "class", "note-meta svelte-1pysysm");
			attr(button, "class", "note-card svelte-1pysysm");
			toggle_class(button, "selected", /*selectedNoteId*/ ctx[1] === /*note*/ ctx[9].id);
			this.first = li;
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, button);
			append(button, div0);
			append(div0, h4);
			append(h4, t0);
			append(div0, t1);
			append(div0, span0);
			append(span0, t2);
			append(button, t3);
			append(button, p);
			append(p, t4);
			append(button, t5);
			append(button, div1);
			append(div1, span1);
			append(span1, t6);
			append(li, t7);

			if (!mounted) {
				dispose = listen(button, "click", click_handler_1);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*notes*/ 1 && t0_value !== (t0_value = (/*note*/ ctx[9].title || 'Untitled') + "")) set_data(t0, t0_value);
			if (dirty & /*notes*/ 1 && t2_value !== (t2_value = /*note*/ ctx[9].category + "")) set_data(t2, t2_value);

			if (dirty & /*notes*/ 1 && span0_class_value !== (span0_class_value = "badge " + (/*categoryColors*/ ctx[4][/*note*/ ctx[9].category] || 'badge-other') + " svelte-1pysysm")) {
				attr(span0, "class", span0_class_value);
			}

			if (dirty & /*notes*/ 1 && t4_value !== (t4_value = (truncateContent(/*note*/ ctx[9].content) || 'No content') + "")) set_data(t4, t4_value);
			if (dirty & /*notes*/ 1 && t6_value !== (t6_value = formatDate(/*note*/ ctx[9].modifiedAt) + "")) set_data(t6, t6_value);

			if (dirty & /*selectedNoteId, notes*/ 3) {
				toggle_class(button, "selected", /*selectedNoteId*/ ctx[1] === /*note*/ ctx[9].id);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(li);
			}

			mounted = false;
			dispose();
		}
	};
}

// (80:10) {:else}
function create_else_block_1(ctx) {
	let t;

	return {
		c() {
			t = text("ðŸ“");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (78:10) {#if searchQuery}
function create_if_block_2(ctx) {
	let t;

	return {
		c() {
			t = text("ðŸ”");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (87:10) {:else}
function create_else_block(ctx) {
	let t;

	return {
		c() {
			t = text("No notes yet. Create your first note!");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (85:10) {#if searchQuery}
function create_if_block_1(ctx) {
	let t0;
	let t1;
	let t2;

	return {
		c() {
			t0 = text("No notes found matching \"");
			t1 = text(/*searchQuery*/ ctx[2]);
			t2 = text("\"");
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, t2, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*searchQuery*/ 4) set_data(t1, /*searchQuery*/ ctx[2]);
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(t1);
				detach(t2);
			}
		}
	};
}

function create_fragment(ctx) {
	let div4;
	let div2;
	let div0;
	let svg;
	let circle;
	let line;
	let t0;
	let input;
	let t1;
	let t2;
	let div1;
	let t3_value = /*notes*/ ctx[0].length + "";
	let t3;
	let t4;
	let t5_value = (/*notes*/ ctx[0].length !== 1 ? 's' : '') + "";
	let t5;
	let t6;
	let div3;
	let mounted;
	let dispose;
	let if_block0 = /*searchQuery*/ ctx[2] && create_if_block_3(ctx);

	function select_block_type(ctx, dirty) {
		if (/*notes*/ ctx[0].length === 0) return create_if_block;
		return create_else_block_2;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block1 = current_block_type(ctx);

	return {
		c() {
			div4 = element("div");
			div2 = element("div");
			div0 = element("div");
			svg = svg_element("svg");
			circle = svg_element("circle");
			line = svg_element("line");
			t0 = space();
			input = element("input");
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			div1 = element("div");
			t3 = text(t3_value);
			t4 = text(" note");
			t5 = text(t5_value);
			t6 = space();
			div3 = element("div");
			if_block1.c();
			attr(circle, "cx", "11");
			attr(circle, "cy", "11");
			attr(circle, "r", "8");
			attr(line, "x1", "21");
			attr(line, "y1", "21");
			attr(line, "x2", "16.65");
			attr(line, "y2", "16.65");
			attr(svg, "class", "search-icon svelte-1pysysm");
			attr(svg, "width", "16");
			attr(svg, "height", "16");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "fill", "none");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", "2");
			attr(input, "type", "text");
			attr(input, "class", "search-input svelte-1pysysm");
			attr(input, "placeholder", "Search notes...");
			input.value = /*searchQuery*/ ctx[2];
			attr(div0, "class", "search-wrapper svelte-1pysysm");
			attr(div1, "class", "list-count svelte-1pysysm");
			attr(div2, "class", "list-header svelte-1pysysm");
			attr(div3, "class", "list-content svelte-1pysysm");
			attr(div4, "class", "note-list svelte-1pysysm");
		},
		m(target, anchor) {
			insert(target, div4, anchor);
			append(div4, div2);
			append(div2, div0);
			append(div0, svg);
			append(svg, circle);
			append(svg, line);
			append(div0, t0);
			append(div0, input);
			append(div0, t1);
			if (if_block0) if_block0.m(div0, null);
			append(div2, t2);
			append(div2, div1);
			append(div1, t3);
			append(div1, t4);
			append(div1, t5);
			append(div4, t6);
			append(div4, div3);
			if_block1.m(div3, null);

			if (!mounted) {
				dispose = listen(input, "input", /*handleSearch*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*searchQuery*/ 4 && input.value !== /*searchQuery*/ ctx[2]) {
				input.value = /*searchQuery*/ ctx[2];
			}

			if (/*searchQuery*/ ctx[2]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					if_block0.m(div0, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*notes*/ 1 && t3_value !== (t3_value = /*notes*/ ctx[0].length + "")) set_data(t3, t3_value);
			if (dirty & /*notes*/ 1 && t5_value !== (t5_value = (/*notes*/ ctx[0].length !== 1 ? 's' : '') + "")) set_data(t5, t5_value);

			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(div3, null);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(div4);
			}

			if (if_block0) if_block0.d();
			if_block1.d();
			mounted = false;
			dispose();
		}
	};
}

function formatDate(dateString) {
	const date = new Date(dateString);
	const now = new Date();
	const diff = now.getTime() - date.getTime();
	const days = Math.floor(diff / (1000 * 60 * 60 * 24));

	if (days === 0) {
		return 'Today';
	} else if (days === 1) {
		return 'Yesterday';
	} else if (days < 7) {
		return `${days} days ago`;
	} else {
		return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
	}
}

function truncateContent(content, maxLength = 80) {
	if (content.length <= maxLength) return content;
	return content.substring(0, maxLength).trim() + '...';
}

function instance($$self, $$props, $$invalidate) {
	let { notes = [] } = $$props;
	let { selectedNoteId = null } = $$props;
	let { searchQuery = '' } = $$props;
	const dispatch = createEventDispatcher();

	const categoryColors = {
		personal: 'badge-personal',
		work: 'badge-work',
		financial: 'badge-financial',
		medical: 'badge-medical',
		passwords: 'badge-passwords',
		other: 'badge-other'
	};

	function handleSearch(event) {
		const target = event.target;
		dispatch('search', { query: target.value });
	}

	function selectNote(noteId) {
		dispatch('selectNote', { noteId });
	}

	const click_handler = () => dispatch('search', { query: '' });
	const click_handler_1 = note => selectNote(note.id);

	$$self.$$set = $$props => {
		if ('notes' in $$props) $$invalidate(0, notes = $$props.notes);
		if ('selectedNoteId' in $$props) $$invalidate(1, selectedNoteId = $$props.selectedNoteId);
		if ('searchQuery' in $$props) $$invalidate(2, searchQuery = $$props.searchQuery);
	};

	return [
		notes,
		selectedNoteId,
		searchQuery,
		dispatch,
		categoryColors,
		handleSearch,
		selectNote,
		click_handler,
		click_handler_1
	];
}

class NoteList extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				notes: 0,
				selectedNoteId: 1,
				searchQuery: 2
			},
			add_css
		);
	}
}

export default NoteList;