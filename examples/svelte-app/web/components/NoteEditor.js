/* NoteEditor.svelte generated by Svelte v4.2.20 */
import {
	SvelteComponent,
	append,
	append_styles,
	attr,
	destroy_each,
	detach,
	element,
	empty,
	ensure_array_like,
	init,
	insert,
	listen,
	noop,
	run_all,
	safe_not_equal,
	select_option,
	set_data,
	set_input_value,
	space,
	svg_element,
	text
} from "svelte/internal";

import "svelte/internal/disclose-version";
import { createEventDispatcher } from 'svelte';

function add_css(target) {
	append_styles(target, "svelte-15b5jox", ".note-editor.svelte-15b5jox.svelte-15b5jox{flex:1;display:flex;flex-direction:column;background-color:var(--bg-primary);overflow:hidden;position:relative}.editor-header.svelte-15b5jox.svelte-15b5jox{padding:var(--spacing-lg);border-bottom:1px solid var(--border-color)}.editor-title-row.svelte-15b5jox.svelte-15b5jox{display:flex;align-items:center;gap:var(--spacing-md);margin-bottom:var(--spacing-md)}.title-input.svelte-15b5jox.svelte-15b5jox{flex:1;font-size:24px;font-weight:600;color:var(--text-primary);background:none;border:none;outline:none;padding:0}.title-input.svelte-15b5jox.svelte-15b5jox::placeholder{color:var(--text-muted)}.editor-actions.svelte-15b5jox.svelte-15b5jox{display:flex;gap:var(--spacing-xs)}.editor-meta.svelte-15b5jox.svelte-15b5jox{display:flex;align-items:center;gap:var(--spacing-md)}.category-select.svelte-15b5jox.svelte-15b5jox{padding:var(--spacing-xs) var(--spacing-sm);font-size:12px;color:var(--text-primary);background-color:var(--bg-secondary);border:1px solid var(--border-color);border-radius:var(--radius-md);outline:none;cursor:pointer}.meta-date.svelte-15b5jox.svelte-15b5jox{font-size:12px;color:var(--text-muted)}.editor-content.svelte-15b5jox.svelte-15b5jox{flex:1;padding:var(--spacing-lg);overflow-y:auto}.content-textarea.svelte-15b5jox.svelte-15b5jox{width:100%;height:100%;min-height:300px;font-size:15px;line-height:1.7;color:var(--text-primary);background:none;border:none;outline:none;resize:none;font-family:inherit}.content-textarea.svelte-15b5jox.svelte-15b5jox::placeholder{color:var(--text-muted)}.editor-footer.svelte-15b5jox.svelte-15b5jox{display:flex;align-items:center;justify-content:space-between;padding:var(--spacing-md) var(--spacing-lg);border-top:1px solid var(--border-color);background-color:var(--bg-secondary)}.footer-info.svelte-15b5jox.svelte-15b5jox{font-size:12px}.unsaved-indicator.svelte-15b5jox.svelte-15b5jox{color:var(--warning)}.saved-indicator.svelte-15b5jox.svelte-15b5jox{color:var(--text-muted)}.empty-editor.svelte-15b5jox.svelte-15b5jox{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:var(--spacing-xl);text-align:center;color:var(--text-muted)}.empty-editor.svelte-15b5jox h3.svelte-15b5jox{margin-top:var(--spacing-md);margin-bottom:var(--spacing-sm);color:var(--text-secondary)}.empty-editor.svelte-15b5jox p.svelte-15b5jox{max-width:300px}.delete-confirm-overlay.svelte-15b5jox.svelte-15b5jox{position:absolute;inset:0;background-color:rgba(0, 0, 0, 0.7);display:flex;align-items:center;justify-content:center;z-index:100;animation:fadeIn var(--transition-fast)}.delete-confirm-dialog.svelte-15b5jox.svelte-15b5jox{background-color:var(--bg-secondary);border:1px solid var(--border-color);border-radius:var(--radius-lg);padding:var(--spacing-lg);max-width:400px;width:90%;animation:slideUp var(--transition-normal)}.delete-confirm-dialog.svelte-15b5jox h3.svelte-15b5jox{margin-bottom:var(--spacing-sm);color:var(--error)}.delete-confirm-dialog.svelte-15b5jox p.svelte-15b5jox{color:var(--text-secondary);margin-bottom:var(--spacing-lg)}.dialog-actions.svelte-15b5jox.svelte-15b5jox{display:flex;justify-content:flex-end;gap:var(--spacing-sm)}");
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i];
	return child_ctx;
}

// (168:2) {:else}
function create_else_block_1(ctx) {
	let div1;

	return {
		c() {
			div1 = element("div");
			div1.innerHTML = `<div class="empty-state-icon">üìù</div> <h3 class="svelte-15b5jox">Select a note</h3> <p class="svelte-15b5jox">Choose a note from the list to view and edit its contents, or create a new note.</p>`;
			attr(div1, "class", "empty-editor svelte-15b5jox");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(div1);
			}
		}
	};
}

// (76:2) {#if note}
function create_if_block(ctx) {
	let div3;
	let div1;
	let input;
	let t0;
	let div0;
	let button0;
	let svg0;
	let rect;
	let path0;
	let button0_disabled_value;
	let t1;
	let button1;
	let t2;
	let div2;
	let select;
	let t3;
	let span;
	let t4;
	let t5_value = formatDate(/*note*/ ctx[0].modifiedAt) + "";
	let t5;
	let t6;
	let div4;
	let textarea;
	let t7;
	let div6;
	let div5;
	let t8;
	let button2;
	let svg2;
	let path2;
	let polyline1;
	let polyline2;
	let t9;
	let button2_disabled_value;
	let t10;
	let if_block1_anchor;
	let mounted;
	let dispose;
	let each_value = ensure_array_like(/*categories*/ ctx[6]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	function select_block_type_1(ctx, dirty) {
		if (/*hasChanges*/ ctx[4]) return create_if_block_2;
		return create_else_block;
	}

	let current_block_type = select_block_type_1(ctx, -1);
	let if_block0 = current_block_type(ctx);
	let if_block1 = /*showDeleteConfirm*/ ctx[5] && create_if_block_1(ctx);

	return {
		c() {
			div3 = element("div");
			div1 = element("div");
			input = element("input");
			t0 = space();
			div0 = element("div");
			button0 = element("button");
			svg0 = svg_element("svg");
			rect = svg_element("rect");
			path0 = svg_element("path");
			t1 = space();
			button1 = element("button");
			button1.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>`;
			t2 = space();
			div2 = element("div");
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t3 = space();
			span = element("span");
			t4 = text("Modified ");
			t5 = text(t5_value);
			t6 = space();
			div4 = element("div");
			textarea = element("textarea");
			t7 = space();
			div6 = element("div");
			div5 = element("div");
			if_block0.c();
			t8 = space();
			button2 = element("button");
			svg2 = svg_element("svg");
			path2 = svg_element("path");
			polyline1 = svg_element("polyline");
			polyline2 = svg_element("polyline");
			t9 = text("\n        Save Note");
			t10 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			attr(input, "type", "text");
			attr(input, "class", "title-input svelte-15b5jox");
			input.value = /*title*/ ctx[1];
			attr(input, "placeholder", "Note title...");
			attr(rect, "x", "9");
			attr(rect, "y", "9");
			attr(rect, "width", "13");
			attr(rect, "height", "13");
			attr(rect, "rx", "2");
			attr(rect, "ry", "2");
			attr(path0, "d", "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1");
			attr(svg0, "width", "16");
			attr(svg0, "height", "16");
			attr(svg0, "viewBox", "0 0 24 24");
			attr(svg0, "fill", "none");
			attr(svg0, "stroke", "currentColor");
			attr(svg0, "stroke-width", "2");
			attr(button0, "class", "btn btn-ghost btn-icon");
			attr(button0, "title", "Copy content");
			button0.disabled = button0_disabled_value = !/*content*/ ctx[2];
			attr(button1, "class", "btn btn-ghost btn-icon");
			attr(button1, "title", "Delete note");
			attr(div0, "class", "editor-actions svelte-15b5jox");
			attr(div1, "class", "editor-title-row svelte-15b5jox");
			attr(select, "class", "category-select svelte-15b5jox");
			attr(span, "class", "meta-date svelte-15b5jox");
			attr(div2, "class", "editor-meta svelte-15b5jox");
			attr(div3, "class", "editor-header svelte-15b5jox");
			attr(textarea, "class", "content-textarea svelte-15b5jox");
			textarea.value = /*content*/ ctx[2];
			attr(textarea, "placeholder", "Start writing your note...");
			attr(div4, "class", "editor-content svelte-15b5jox");
			attr(div5, "class", "footer-info svelte-15b5jox");
			attr(path2, "d", "M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z");
			attr(polyline1, "points", "17 21 17 13 7 13 7 21");
			attr(polyline2, "points", "7 3 7 8 15 8");
			attr(svg2, "width", "16");
			attr(svg2, "height", "16");
			attr(svg2, "viewBox", "0 0 24 24");
			attr(svg2, "fill", "none");
			attr(svg2, "stroke", "currentColor");
			attr(svg2, "stroke-width", "2");
			attr(button2, "class", "btn btn-primary");
			button2.disabled = button2_disabled_value = !/*hasChanges*/ ctx[4];
			attr(div6, "class", "editor-footer svelte-15b5jox");
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div1);
			append(div1, input);
			append(div1, t0);
			append(div1, div0);
			append(div0, button0);
			append(button0, svg0);
			append(svg0, rect);
			append(svg0, path0);
			append(div0, t1);
			append(div0, button1);
			append(div3, t2);
			append(div3, div2);
			append(div2, select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(select, null);
				}
			}

			select_option(select, /*category*/ ctx[3]);
			append(div2, t3);
			append(div2, span);
			append(span, t4);
			append(span, t5);
			insert(target, t6, anchor);
			insert(target, div4, anchor);
			append(div4, textarea);
			insert(target, t7, anchor);
			insert(target, div6, anchor);
			append(div6, div5);
			if_block0.m(div5, null);
			append(div6, t8);
			append(div6, button2);
			append(button2, svg2);
			append(svg2, path2);
			append(svg2, polyline1);
			append(svg2, polyline2);
			append(button2, t9);
			insert(target, t10, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*handleTitleChange*/ ctx[7]),
					listen(button0, "click", /*copyContent*/ ctx[12]),
					listen(button1, "click", /*click_handler*/ ctx[13]),
					listen(select, "change", /*handleCategoryChange*/ ctx[9]),
					listen(textarea, "input", /*handleContentChange*/ ctx[8]),
					listen(button2, "click", /*saveNote*/ ctx[10])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*title*/ 2 && input.value !== /*title*/ ctx[1]) {
				input.value = /*title*/ ctx[1];
			}

			if (dirty & /*content*/ 4 && button0_disabled_value !== (button0_disabled_value = !/*content*/ ctx[2])) {
				button0.disabled = button0_disabled_value;
			}

			if (dirty & /*categories*/ 64) {
				each_value = ensure_array_like(/*categories*/ ctx[6]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*category, categories*/ 72) {
				select_option(select, /*category*/ ctx[3]);
			}

			if (dirty & /*note*/ 1 && t5_value !== (t5_value = formatDate(/*note*/ ctx[0].modifiedAt) + "")) set_data(t5, t5_value);

			if (dirty & /*content*/ 4) {
				textarea.value = /*content*/ ctx[2];
			}

			if (current_block_type !== (current_block_type = select_block_type_1(ctx, dirty))) {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div5, null);
				}
			}

			if (dirty & /*hasChanges*/ 16 && button2_disabled_value !== (button2_disabled_value = !/*hasChanges*/ ctx[4])) {
				button2.disabled = button2_disabled_value;
			}

			if (/*showDeleteConfirm*/ ctx[5]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(div3);
				detach(t6);
				detach(div4);
				detach(t7);
				detach(div6);
				detach(t10);
				detach(if_block1_anchor);
			}

			destroy_each(each_blocks, detaching);
			if_block0.d();
			if (if_block1) if_block1.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (113:10) {#each categories as cat}
function create_each_block(ctx) {
	let option;
	let t_value = /*cat*/ ctx[16].label + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*cat*/ ctx[16].id;
			set_input_value(option, option.__value);
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(option);
			}
		}
	};
}

// (134:8) {:else}
function create_else_block(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "All changes saved";
			attr(span, "class", "saved-indicator svelte-15b5jox");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}
		}
	};
}

// (132:8) {#if hasChanges}
function create_if_block_2(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Unsaved changes";
			attr(span, "class", "unsaved-indicator svelte-15b5jox");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}
		}
	};
}

// (152:4) {#if showDeleteConfirm}
function create_if_block_1(ctx) {
	let div2;
	let div1;
	let h3;
	let t1;
	let p;
	let t2;
	let t3_value = (/*title*/ ctx[1] || 'Untitled') + "";
	let t3;
	let t4;
	let t5;
	let div0;
	let button0;
	let t7;
	let button1;
	let mounted;
	let dispose;

	return {
		c() {
			div2 = element("div");
			div1 = element("div");
			h3 = element("h3");
			h3.textContent = "Delete Note";
			t1 = space();
			p = element("p");
			t2 = text("Are you sure you want to delete \"");
			t3 = text(t3_value);
			t4 = text("\"? This action cannot be undone.");
			t5 = space();
			div0 = element("div");
			button0 = element("button");
			button0.textContent = "Cancel";
			t7 = space();
			button1 = element("button");
			button1.textContent = "Delete";
			attr(h3, "class", "svelte-15b5jox");
			attr(p, "class", "svelte-15b5jox");
			attr(button0, "class", "btn btn-secondary");
			attr(button1, "class", "btn btn-danger");
			attr(div0, "class", "dialog-actions svelte-15b5jox");
			attr(div1, "class", "delete-confirm-dialog svelte-15b5jox");
			attr(div2, "class", "delete-confirm-overlay svelte-15b5jox");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div1);
			append(div1, h3);
			append(div1, t1);
			append(div1, p);
			append(p, t2);
			append(p, t3);
			append(p, t4);
			append(div1, t5);
			append(div1, div0);
			append(div0, button0);
			append(div0, t7);
			append(div0, button1);

			if (!mounted) {
				dispose = [
					listen(button0, "click", /*click_handler_1*/ ctx[14]),
					listen(button1, "click", /*deleteNote*/ ctx[11])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*title*/ 2 && t3_value !== (t3_value = (/*title*/ ctx[1] || 'Untitled') + "")) set_data(t3, t3_value);
		},
		d(detaching) {
			if (detaching) {
				detach(div2);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment(ctx) {
	let div;

	function select_block_type(ctx, dirty) {
		if (/*note*/ ctx[0]) return create_if_block;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			attr(div, "class", "note-editor svelte-15b5jox");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_block.m(div, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			if_block.d();
		}
	};
}

function formatDate(dateString) {
	return new Date(dateString).toLocaleString('en-US', {
		month: 'short',
		day: 'numeric',
		year: 'numeric',
		hour: 'numeric',
		minute: '2-digit'
	});
}

function instance($$self, $$props, $$invalidate) {
	let { note = null } = $$props;
	const dispatch = createEventDispatcher();

	const categories = [
		{ id: 'personal', label: 'Personal' },
		{ id: 'work', label: 'Work' },
		{ id: 'financial', label: 'Financial' },
		{ id: 'medical', label: 'Medical' },
		{ id: 'passwords', label: 'Passwords' },
		{ id: 'other', label: 'Other' }
	];

	let title = '';
	let content = '';
	let category = 'personal';
	let hasChanges = false;
	let showDeleteConfirm = false;

	function handleTitleChange(event) {
		const target = event.target;
		$$invalidate(1, title = target.value);
		$$invalidate(4, hasChanges = true);
	}

	function handleContentChange(event) {
		const target = event.target;
		$$invalidate(2, content = target.value);
		$$invalidate(4, hasChanges = true);
	}

	function handleCategoryChange(event) {
		const target = event.target;
		$$invalidate(3, category = target.value);
		$$invalidate(4, hasChanges = true);
	}

	function saveNote() {
		if (!note) return;

		const updatedNote = {
			...note,
			title,
			content,
			category,
			modifiedAt: new Date().toISOString()
		};

		dispatch('save', { note: updatedNote });
		$$invalidate(4, hasChanges = false);
	}

	function deleteNote() {
		if (!note) return;
		dispatch('delete', { noteId: note.id });
		$$invalidate(5, showDeleteConfirm = false);
	}

	function copyContent() {
		if (content) {
			dispatch('copy', { text: content });
		}
	}

	const click_handler = () => $$invalidate(5, showDeleteConfirm = true);
	const click_handler_1 = () => $$invalidate(5, showDeleteConfirm = false);

	$$self.$$set = $$props => {
		if ('note' in $$props) $$invalidate(0, note = $$props.note);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*note*/ 1) {
			// Update local state when note changes
			$: if (note) {
				$$invalidate(1, title = note.title);
				$$invalidate(2, content = note.content);
				$$invalidate(3, category = note.category);
				$$invalidate(4, hasChanges = false);
				$$invalidate(5, showDeleteConfirm = false);
			}
		}
	};

	return [
		note,
		title,
		content,
		category,
		hasChanges,
		showDeleteConfirm,
		categories,
		handleTitleChange,
		handleContentChange,
		handleCategoryChange,
		saveNote,
		deleteNote,
		copyContent,
		click_handler,
		click_handler_1
	];
}

class NoteEditor extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { note: 0 }, add_css);
	}
}

export default NoteEditor;