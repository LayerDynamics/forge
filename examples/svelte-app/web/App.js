/* App.svelte generated by Svelte v4.2.20 */
import {
	SvelteComponent,
	append,
	append_styles,
	attr,
	check_outros,
	create_component,
	destroy_component,
	detach,
	element,
	group_outros,
	init,
	insert,
	mount_component,
	noop,
	safe_not_equal,
	set_data,
	space,
	text,
	transition_in,
	transition_out
} from "svelte/internal";

import "svelte/internal/disclose-version";
import { onMount, onDestroy } from 'svelte';

function add_css(target) {
	append_styles(target, "svelte-1gccfya", ".app.svelte-1gccfya.svelte-1gccfya{height:100vh;width:100vw;display:flex;flex-direction:column;background-color:var(--bg-primary);color:var(--text-primary)}.loading-screen.svelte-1gccfya.svelte-1gccfya{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:var(--spacing-md)}.loading-screen.svelte-1gccfya p.svelte-1gccfya{color:var(--text-secondary)}.vault-layout.svelte-1gccfya.svelte-1gccfya{display:flex;height:100%;overflow:hidden}.main-content.svelte-1gccfya.svelte-1gccfya{flex:1;display:flex;overflow:hidden}.notes-panel.svelte-1gccfya.svelte-1gccfya{display:flex;width:100%;height:100%}");
}

// (240:2) {:else}
function create_else_block(ctx) {
	let div;
	let sidebar;
	let t;
	let main;
	let current_block_type_index;
	let if_block;
	let current;

	sidebar = new Sidebar({
			props: {
				selectedCategory: /*selectedCategory*/ ctx[1],
				currentView: /*currentView*/ ctx[8]
			}
		});

	sidebar.$on("categoryChange", /*handleCategoryChange*/ ctx[16]);
	sidebar.$on("viewChange", /*handleViewChange*/ ctx[17]);
	sidebar.$on("newNote", /*handleNewNote*/ ctx[15]);
	sidebar.$on("lock", /*handleLock*/ ctx[13]);
	sidebar.$on("export", handleExport);
	sidebar.$on("import", handleImport);
	const if_block_creators = [create_if_block_3, create_if_block_4];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*currentView*/ ctx[8] === 'notes') return 0;
		if (/*currentView*/ ctx[8] === 'generator') return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_1(ctx, -1))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			div = element("div");
			create_component(sidebar.$$.fragment);
			t = space();
			main = element("main");
			if (if_block) if_block.c();
			attr(main, "class", "main-content svelte-1gccfya");
			attr(div, "class", "vault-layout svelte-1gccfya");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(sidebar, div, null);
			append(div, t);
			append(div, main);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(main, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			const sidebar_changes = {};
			if (dirty & /*selectedCategory*/ 2) sidebar_changes.selectedCategory = /*selectedCategory*/ ctx[1];
			if (dirty & /*currentView*/ 256) sidebar_changes.currentView = /*currentView*/ ctx[8];
			sidebar.$set(sidebar_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(main, null);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(sidebar.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(sidebar.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			destroy_component(sidebar);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}
		}
	};
}

// (233:24) 
function create_if_block_2(ctx) {
	let lockscreen;
	let current;

	lockscreen = new LockScreen({
			props: {
				isFirstTime: /*isFirstTime*/ ctx[4],
				error: /*error*/ ctx[6]
			}
		});

	lockscreen.$on("unlock", /*handleUnlock*/ ctx[11]);
	lockscreen.$on("setup", /*handleSetup*/ ctx[12]);

	return {
		c() {
			create_component(lockscreen.$$.fragment);
		},
		m(target, anchor) {
			mount_component(lockscreen, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const lockscreen_changes = {};
			if (dirty & /*isFirstTime*/ 16) lockscreen_changes.isFirstTime = /*isFirstTime*/ ctx[4];
			if (dirty & /*error*/ 64) lockscreen_changes.error = /*error*/ ctx[6];
			lockscreen.$set(lockscreen_changes);
		},
		i(local) {
			if (current) return;
			transition_in(lockscreen.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(lockscreen.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(lockscreen, detaching);
		}
	};
}

// (228:2) {#if isLoading}
function create_if_block_1(ctx) {
	let div1;

	return {
		c() {
			div1 = element("div");
			div1.innerHTML = `<div class="spinner"></div> <p class="svelte-1gccfya">Loading...</p>`;
			attr(div1, "class", "loading-screen svelte-1gccfya");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(div1);
			}
		}
	};
}

// (271:46) 
function create_if_block_4(ctx) {
	let passwordgenerator;
	let current;
	passwordgenerator = new PasswordGenerator({});
	passwordgenerator.$on("copy", handleCopyToClipboard);

	return {
		c() {
			create_component(passwordgenerator.$$.fragment);
		},
		m(target, anchor) {
			mount_component(passwordgenerator, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(passwordgenerator.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(passwordgenerator.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(passwordgenerator, detaching);
		}
	};
}

// (254:8) {#if currentView === 'notes'}
function create_if_block_3(ctx) {
	let div;
	let notelist;
	let t;
	let noteeditor;
	let current;

	notelist = new NoteList({
			props: {
				notes: /*filteredNotes*/ ctx[9],
				selectedNoteId: /*selectedNoteId*/ ctx[0],
				searchQuery: /*searchQuery*/ ctx[2]
			}
		});

	notelist.$on("selectNote", /*handleSelectNote*/ ctx[14]);
	notelist.$on("search", /*handleSearch*/ ctx[18]);

	noteeditor = new NoteEditor({
			props: { note: /*selectedNote*/ ctx[10] }
		});

	noteeditor.$on("save", handleSaveNote);
	noteeditor.$on("delete", handleDeleteNote);
	noteeditor.$on("copy", handleCopyToClipboard);

	return {
		c() {
			div = element("div");
			create_component(notelist.$$.fragment);
			t = space();
			create_component(noteeditor.$$.fragment);
			attr(div, "class", "notes-panel svelte-1gccfya");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(notelist, div, null);
			append(div, t);
			mount_component(noteeditor, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const notelist_changes = {};
			if (dirty & /*filteredNotes*/ 512) notelist_changes.notes = /*filteredNotes*/ ctx[9];
			if (dirty & /*selectedNoteId*/ 1) notelist_changes.selectedNoteId = /*selectedNoteId*/ ctx[0];
			if (dirty & /*searchQuery*/ 4) notelist_changes.searchQuery = /*searchQuery*/ ctx[2];
			notelist.$set(notelist_changes);
			const noteeditor_changes = {};
			if (dirty & /*selectedNote*/ 1024) noteeditor_changes.note = /*selectedNote*/ ctx[10];
			noteeditor.$set(noteeditor_changes);
		},
		i(local) {
			if (current) return;
			transition_in(notelist.$$.fragment, local);
			transition_in(noteeditor.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(notelist.$$.fragment, local);
			transition_out(noteeditor.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			destroy_component(notelist);
			destroy_component(noteeditor);
		}
	};
}

// (278:2) {#if toast}
function create_if_block(ctx) {
	let div;
	let t_value = /*toast*/ ctx[7].message + "";
	let t;
	let div_class_value;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", div_class_value = "toast toast-" + /*toast*/ ctx[7].type + " svelte-1gccfya");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*toast*/ 128 && t_value !== (t_value = /*toast*/ ctx[7].message + "")) set_data(t, t_value);

			if (dirty & /*toast*/ 128 && div_class_value !== (div_class_value = "toast toast-" + /*toast*/ ctx[7].type + " svelte-1gccfya")) {
				attr(div, "class", div_class_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}
		}
	};
}

function create_fragment(ctx) {
	let div;
	let current_block_type_index;
	let if_block0;
	let t;
	let current;
	const if_block_creators = [create_if_block_1, create_if_block_2, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*isLoading*/ ctx[5]) return 0;
		if (!/*isUnlocked*/ ctx[3]) return 1;
		return 2;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = /*toast*/ ctx[7] && create_if_block(ctx);

	return {
		c() {
			div = element("div");
			if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			attr(div, "class", "app svelte-1gccfya");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			append(div, t);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in(if_block0, 1);
				if_block0.m(div, t);
			}

			if (/*toast*/ ctx[7]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
		}
	};
}

function checkVaultStatus() {
	window.host.send('vault:status');
}

function handleSaveNote(event) {
	window.host.send('note:update', { note: event.detail.note });
}

function handleDeleteNote(event) {
	window.host.send('note:delete', { noteId: event.detail.noteId });
}

function handleCopyToClipboard(event) {
	window.host.send('clipboard:copy', { text: event.detail.text });
}

function handleExport() {
	window.host.send('export:backup');
}

function handleImport() {
	window.host.send('import:backup');
}

function instance($$self, $$props, $$invalidate) {
	let selectedNote;
	let filteredNotes;
	let isUnlocked = false;
	let isFirstTime = true;
	let isLoading = true;
	let error = '';
	let toast = null;

	// Vault state
	let notes = [];

	let selectedNoteId = null;
	let selectedNoteContent = null; // Full note with content
	let selectedCategory = 'all';
	let searchQuery = '';
	let currentView = 'notes';

	// Activity tracking for auto-lock
	let activityInterval;

	onMount(() => {
		setupEventListeners();
		checkVaultStatus();
		startActivityTracking();
	});

	onDestroy(() => {
		if (activityInterval) {
			clearInterval(activityInterval);
		}
	});

	function setupEventListeners() {
		// Vault state events
		window.host.on('vault:state', data => {
			const { unlocked, firstTime } = data;
			$$invalidate(3, isUnlocked = unlocked);
			$$invalidate(4, isFirstTime = firstTime);
			$$invalidate(5, isLoading = false);

			if (unlocked) {
				loadNotes();
			}
		});

		window.host.on('vault:unlock-result', data => {
			const { success, error: err, firstTime } = data;
			$$invalidate(5, isLoading = false);

			if (success) {
				$$invalidate(3, isUnlocked = true);
				$$invalidate(4, isFirstTime = firstTime ?? false);
				loadNotes();
				showToast('Vault unlocked', 'success');
			} else {
				$$invalidate(6, error = err || 'Failed to unlock vault');
				showToast(error, 'error');
			}
		});

		// Note events
		window.host.on('note:list-result', data => {
			const { notes: loadedNotes } = data;
			$$invalidate(19, notes = loadedNotes || []);
		});

		window.host.on('note:saved', data => {
			const { success, note } = data;

			if (success && note) {
				const index = notes.findIndex(n => n.id === note.id);

				if (index >= 0) {
					$$invalidate(19, notes[index] = note, notes);
					$$invalidate(19, notes = [...notes]);
				} else {
					$$invalidate(19, notes = [...notes, note]);
				}

				showToast('Note saved', 'success');
			}
		});

		window.host.on('note:deleted', data => {
			const { success, noteId } = data;

			if (success) {
				$$invalidate(19, notes = notes.filter(n => n.id !== noteId));

				if (selectedNoteId === noteId) {
					$$invalidate(0, selectedNoteId = null);
					$$invalidate(20, selectedNoteContent = null);
				}

				showToast('Note deleted', 'success');
			}
		});

		// Handle full note content response
		window.host.on('note:get-result', data => {
			const { note } = data;

			if (note) {
				$$invalidate(20, selectedNoteContent = note);
			}
		});

		// Auto-lock warning
		window.host.on('auto-lock:warning', () => {
			showToast('Vault will lock in 30 seconds due to inactivity', 'warning');
		});

		// Clipboard events
		window.host.on('clipboard:copied', data => {
			const { success } = data;

			if (success) {
				showToast('Copied to clipboard', 'success');
			}
		});

		// Export/Import events
		window.host.on('export:result', data => {
			const { success, error: err } = data;

			if (success) {
				showToast('Backup exported successfully', 'success');
			} else {
				showToast(err || 'Export failed', 'error');
			}
		});

		window.host.on('import:result', data => {
			const { success, error: err, count } = data;

			if (success) {
				loadNotes();
				showToast(`Imported ${count} notes successfully`, 'success');
			} else {
				showToast(err || 'Import failed', 'error');
			}
		});
	}

	function loadNotes() {
		window.host.send('note:list', {
			category: selectedCategory === 'all'
			? undefined
			: selectedCategory
		});
	}

	function startActivityTracking() {
		// Send activity ping every 30 seconds
		activityInterval = setInterval(
			() => {
				if (isUnlocked) {
					window.host.send('activity:ping');
				}
			},
			30000
		);

		// Track user activity
		const trackActivity = () => {
			if (isUnlocked) {
				window.host.send('activity:ping');
			}
		};

		document.addEventListener('mousemove', trackActivity);
		document.addEventListener('keydown', trackActivity);
		document.addEventListener('click', trackActivity);
	}

	function handleUnlock(event) {
		$$invalidate(5, isLoading = true);
		$$invalidate(6, error = '');
		window.host.send('vault:unlock', { password: event.detail.password });
	}

	function handleSetup(event) {
		$$invalidate(5, isLoading = true);
		$$invalidate(6, error = '');
		window.host.send('vault:setup', { password: event.detail.password });
	}

	function handleLock() {
		window.host.send('vault:lock');
		$$invalidate(3, isUnlocked = false);
		$$invalidate(19, notes = []);
		$$invalidate(0, selectedNoteId = null);
		$$invalidate(20, selectedNoteContent = null);
		showToast('Vault locked', 'success');
	}

	function handleSelectNote(event) {
		$$invalidate(0, selectedNoteId = event.detail.noteId);
		$$invalidate(20, selectedNoteContent = null); // Clear previous content
		$$invalidate(8, currentView = 'notes');

		// Fetch full note content
		window.host.send('note:get', { id: event.detail.noteId });
	}

	function handleNewNote() {
		const newNote = {
			id: '',
			title: 'Untitled Note',
			content: '',
			category: selectedCategory === 'all'
			? 'personal'
			: selectedCategory,
			createdAt: new Date().toISOString(),
			modifiedAt: new Date().toISOString()
		};

		window.host.send('note:create', { note: newNote });
	}

	function handleCategoryChange(event) {
		$$invalidate(1, selectedCategory = event.detail.category);
		loadNotes();
	}

	function handleViewChange(event) {
		$$invalidate(8, currentView = event.detail.view);

		if (currentView === 'generator') {
			$$invalidate(0, selectedNoteId = null);
		}
	}

	function handleSearch(event) {
		$$invalidate(2, searchQuery = event.detail.query);
	}

	function showToast(message, type) {
		$$invalidate(7, toast = { message, type });

		setTimeout(
			() => {
				$$invalidate(7, toast = null);
			},
			3000
		);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*selectedNoteContent, selectedNoteId, notes*/ 1572865) {
			// Computed - use full content if available, otherwise fall back to list item
			$: $$invalidate(10, selectedNote = selectedNoteContent && selectedNoteContent.id === selectedNoteId
			? selectedNoteContent
			: notes.find(n => n.id === selectedNoteId) || null);
		}

		if ($$self.$$.dirty & /*notes, selectedCategory, searchQuery*/ 524294) {
			$: $$invalidate(9, filteredNotes = notes.filter(note => {
				const matchesCategory = selectedCategory === 'all' || note.category === selectedCategory;
				const matchesSearch = !searchQuery || note.title.toLowerCase().includes(searchQuery.toLowerCase()) || note.content.toLowerCase().includes(searchQuery.toLowerCase());
				return matchesCategory && matchesSearch;
			}));
		}
	};

	return [
		selectedNoteId,
		selectedCategory,
		searchQuery,
		isUnlocked,
		isFirstTime,
		isLoading,
		error,
		toast,
		currentView,
		filteredNotes,
		selectedNote,
		handleUnlock,
		handleSetup,
		handleLock,
		handleSelectNote,
		handleNewNote,
		handleCategoryChange,
		handleViewChange,
		handleSearch,
		notes,
		selectedNoteContent
	];
}

class App extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);
	}
}

export default App;