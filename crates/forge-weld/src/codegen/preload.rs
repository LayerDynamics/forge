//! Preload script generator for Forge applications
//!
//! This module generates the preload.ts script that is injected into WebView
//! renderers. It provides the `window.host` bridge for renderer <-> Deno
//! communication.

use crate::ir::WeldModule;

/// Generator for the preload.ts script
///
/// The preload script runs in the browser context and provides:
/// - `window.host` bridge for IPC communication
/// - HMR (Hot Module Replacement) client for dev mode
/// - Extension-derived type information
pub struct PreloadGenerator {
    modules: Vec<WeldModule>,
    enable_hmr: bool,
}

impl PreloadGenerator {
    /// Create a new preload generator
    pub fn new() -> Self {
        Self {
            modules: Vec::new(),
            enable_hmr: true,
        }
    }

    /// Create a preload generator with extension modules
    pub fn with_modules(modules: Vec<WeldModule>) -> Self {
        Self {
            modules,
            enable_hmr: true,
        }
    }

    /// Add a module to include in the preload
    pub fn add_module(mut self, module: WeldModule) -> Self {
        self.modules.push(module);
        self
    }

    /// Disable HMR client generation
    pub fn disable_hmr(mut self) -> Self {
        self.enable_hmr = false;
        self
    }

    /// Generate the complete preload.ts script
    pub fn generate(&self) -> String {
        let mut output = String::new();

        // File header
        output.push_str(&self.generate_header());

        // Global type declarations
        output.push_str(&self.generate_global_types());

        // Extension metadata (derived from modules)
        output.push_str(&self.generate_extension_metadata());

        // HMR connection function
        if self.enable_hmr {
            output.push_str(&self.generate_hmr_function());
        }

        // Main IIFE
        output.push_str(&self.generate_main_iife());

        output
    }

    /// Generate file header comment
    fn generate_header(&self) -> String {
        let mut output = String::new();

        output.push_str("// Preload script injected into WebView renderer\n");
        output.push_str("// Provides window.host bridge for renderer <-> Deno communication\n");
        output.push_str("// \n");
        output.push_str("// AUTO-GENERATED by forge-weld PreloadGenerator\n");
        output.push_str("// DO NOT EDIT MANUALLY\n");
        output.push_str("//\n");
        output.push_str("// Note: This runs in the BROWSER context, not Deno - but we use globalThis for consistency\n\n");

        output
    }

    /// Generate global type declarations
    fn generate_global_types(&self) -> String {
        let mut output = String::new();

        output.push_str("// Extend globalThis for browser environment\n");
        output.push_str("declare global {\n");
        output.push_str("  var __host_dispatch: ((msg: { channel: string; payload: unknown }) => void) | undefined;\n");
        output.push_str("  var host: HostBridge | undefined;\n");
        output.push_str("  var ipc: { postMessage(message: string): void } | undefined;\n");
        output.push_str("}\n\n");

        output.push_str("type ListenerCallback = (payload: unknown) => void;\n\n");

        output.push_str("interface HostBridge {\n");
        output.push_str("  /** Register a listener for messages from Deno */\n");
        output.push_str("  on(channel: string, cb: ListenerCallback): void;\n");
        output.push_str("  /** Remove a listener */\n");
        output.push_str("  off(channel: string, cb: ListenerCallback): void;\n");
        output.push_str("  /** Emit to local listeners (within renderer) */\n");
        output.push_str("  emit(channel: string, payload?: unknown): void;\n");
        output.push_str("  /** Send a message to Deno (via IPC) */\n");
        output.push_str("  send(channel: string, payload?: unknown): void;\n");
        output.push_str("}\n\n");

        output
    }

    /// Generate extension metadata from modules
    fn generate_extension_metadata(&self) -> String {
        if self.modules.is_empty() {
            return String::new();
        }

        let mut output = String::new();

        output.push_str("// Extension metadata (derived from forge-weld modules)\n");
        output.push_str("const _extensionMeta = {\n");

        for module in &self.modules {
            let module_name = module
                .specifier
                .split_once(':')
                .map(|(_, name)| name)
                .unwrap_or(&module.specifier);

            output.push_str(&format!("  \"{}\": {{\n", module_name));
            output.push_str(&format!("    specifier: \"{}\",\n", module.specifier));

            // List ops
            let op_names: Vec<String> = module
                .ops
                .iter()
                .map(|op| format!("\"{}\"", op.ts_name))
                .collect();
            output.push_str(&format!("    ops: [{}],\n", op_names.join(", ")));

            // Extensibility info
            output.push_str(&format!(
                "    extensible: {{ hooks: {}, handlers: {} }},\n",
                module.extensibility.hooks_enabled, module.extensibility.handlers_enabled
            ));

            output.push_str("  },\n");
        }

        output.push_str("} as const;\n\n");

        // Type for extension names
        let ext_names: Vec<String> = self
            .modules
            .iter()
            .map(|m| {
                let name = m
                    .specifier
                    .split_once(':')
                    .map(|(_, n)| n)
                    .unwrap_or(&m.specifier);
                format!("\"{}\"", name)
            })
            .collect();

        if !ext_names.is_empty() {
            output.push_str(&format!(
                "type ExtensionName = {};\n\n",
                ext_names.join(" | ")
            ));
        }

        output
    }

    /// Generate HMR connection function
    fn generate_hmr_function(&self) -> String {
        let mut output = String::new();

        output
            .push_str("// HMR connection function (hoisted to avoid inner declaration warning)\n");
        output.push_str("function connectHMR(\n");
        output.push_str("  hmrPort: number,\n");
        output.push_str("  maxAttempts: number,\n");
        output.push_str("  attemptRef: { current: number },\n");
        output.push_str("  socketRef: { current: WebSocket | null }\n");
        output.push_str("): void {\n");
        output.push_str("  try {\n");
        output.push_str("    socketRef.current = new WebSocket(`ws://127.0.0.1:${hmrPort}`);\n\n");

        output.push_str("    socketRef.current.onopen = () => {\n");
        output.push_str("      console.debug(\"[HMR] Connected to dev server\");\n");
        output.push_str("      attemptRef.current = 0;\n");
        output.push_str("    };\n\n");

        output.push_str("    socketRef.current.onmessage = (event) => {\n");
        output.push_str("      const msg = event.data as string;\n\n");

        output.push_str("      if (msg.startsWith(\"css:\")) {\n");
        output
            .push_str("        // Hot CSS reload - update stylesheets without full page reload\n");
        output.push_str("        const changedFile = msg.slice(4);\n");
        output.push_str("        console.debug(\"[HMR] CSS changed:\", changedFile);\n\n");

        output.push_str(
            "        document.querySelectorAll('link[rel=\"stylesheet\"]').forEach((link) => {\n",
        );
        output.push_str("          const href = link.getAttribute(\"href\");\n");
        output.push_str("          if (href) {\n");
        output.push_str("            // Add cache-busting query param\n");
        output
            .push_str("            const newHref = href.split(\"?\")[0] + \"?t=\" + Date.now();\n");
        output.push_str("            link.setAttribute(\"href\", newHref);\n");
        output.push_str("          }\n");
        output.push_str("        });\n");
        output.push_str("      } else if (msg.startsWith(\"reload:\")) {\n");
        output.push_str("        // Full page reload for non-CSS changes\n");
        output.push_str("        const changedFile = msg.slice(7);\n");
        output
            .push_str("        console.debug(\"[HMR] File changed, reloading:\", changedFile);\n");
        output.push_str("        location.reload();\n");
        output.push_str("      }\n");
        output.push_str("    };\n\n");

        output.push_str("    socketRef.current.onclose = () => {\n");
        output.push_str("      console.debug(\"[HMR] Disconnected from dev server\");\n");
        output.push_str("      socketRef.current = null;\n\n");

        output.push_str("      // Attempt reconnect\n");
        output.push_str("      if (attemptRef.current < maxAttempts) {\n");
        output.push_str("        attemptRef.current++;\n");
        output.push_str("        setTimeout(\n");
        output
            .push_str("          () => connectHMR(hmrPort, maxAttempts, attemptRef, socketRef),\n");
        output.push_str("          1000 * attemptRef.current\n");
        output.push_str("        );\n");
        output.push_str("      }\n");
        output.push_str("    };\n\n");

        output.push_str("    socketRef.current.onerror = () => {\n");
        output.push_str("      // Silent error - HMR is optional in dev mode\n");
        output.push_str(
            "      console.debug(\"[HMR] Connection error (dev server may not be running)\");\n",
        );
        output.push_str("    };\n");
        output.push_str("  } catch {\n");
        output.push_str("    // HMR not available - this is fine, it's optional\n");
        output.push_str(
            "    console.debug(\"[HMR] Failed to connect (dev server may not be running)\");\n",
        );
        output.push_str("  }\n");
        output.push_str("}\n\n");

        output
    }

    /// Generate main IIFE
    fn generate_main_iife(&self) -> String {
        let mut output = String::new();

        output.push_str("(() => {\n");
        output.push_str("  // Check we're in a browser context\n");
        output.push_str("  if (typeof document === \"undefined\") {\n");
        output.push_str("    return;\n");
        output.push_str("  }\n\n");

        // Message queue
        output.push_str("  // Message queue for when IPC isn't ready yet\n");
        output.push_str("  const pendingMessages: string[] = [];\n");
        output.push_str("  let ipcReady = !!globalThis.ipc;\n\n");

        // sendViaIpc function
        output.push_str("  // Function to send message, queuing if IPC not ready\n");
        output.push_str("  function sendViaIpc(msg: string) {\n");
        output.push_str("    if (globalThis.ipc) {\n");
        output.push_str("      globalThis.ipc.postMessage(msg);\n");
        output.push_str("    } else {\n");
        output.push_str("      pendingMessages.push(msg);\n");
        output.push_str("    }\n");
        output.push_str("  }\n\n");

        // checkIpcReady function
        output.push_str("  // Poll for IPC availability and flush queue\n");
        output.push_str("  function checkIpcReady() {\n");
        output.push_str("    if (globalThis.ipc && !ipcReady) {\n");
        output.push_str("      ipcReady = true;\n");
        output.push_str("      while (pendingMessages.length > 0) {\n");
        output.push_str("        const msg = pendingMessages.shift()!;\n");
        output.push_str("        globalThis.ipc.postMessage(msg);\n");
        output.push_str("      }\n");
        output.push_str("    } else if (!globalThis.ipc) {\n");
        output.push_str("      // Keep polling\n");
        output.push_str("      setTimeout(checkIpcReady, 10);\n");
        output.push_str("    }\n");
        output.push_str("  }\n\n");

        output.push_str("  // Start polling if IPC not immediately available\n");
        output.push_str("  if (!globalThis.ipc) {\n");
        output.push_str("    checkIpcReady();\n");
        output.push_str("  }\n\n");

        // Listeners map
        output.push_str("  const listeners = new Map<string, ListenerCallback[]>();\n\n");

        // __host_dispatch
        output.push_str(
            "  // Internal dispatch function called by host when sending messages to renderer\n",
        );
        output.push_str("  globalThis.__host_dispatch = function (msg: { channel: string; payload: unknown }) {\n");
        output.push_str("    const { channel, payload } = msg;\n");
        output.push_str("    const arr = listeners.get(channel) || [];\n");
        output.push_str("    for (const cb of arr) {\n");
        output.push_str("      try {\n");
        output.push_str("        cb(payload);\n");
        output.push_str("      } catch (e) {\n");
        output.push_str("        console.error(\"[host.dispatch] Error in listener:\", e);\n");
        output.push_str("      }\n");
        output.push_str("    }\n");
        output.push_str("  };\n\n");

        // host bridge
        output.push_str("  // Public API exposed to renderer scripts\n");
        output.push_str("  globalThis.host = {\n");
        output.push_str("    on(channel: string, cb: ListenerCallback) {\n");
        output.push_str("      if (!listeners.has(channel)) {\n");
        output.push_str("        listeners.set(channel, []);\n");
        output.push_str("      }\n");
        output.push_str("      listeners.get(channel)!.push(cb);\n");
        output.push_str("    },\n\n");

        output.push_str("    off(channel: string, cb: ListenerCallback) {\n");
        output.push_str("      const arr = listeners.get(channel);\n");
        output.push_str("      if (arr) {\n");
        output.push_str("        const idx = arr.indexOf(cb);\n");
        output.push_str("        if (idx >= 0) arr.splice(idx, 1);\n");
        output.push_str("      }\n");
        output.push_str("    },\n\n");

        output.push_str("    emit(channel: string, payload?: unknown) {\n");
        output.push_str("      // Dispatch to local listeners first\n");
        output.push_str("      const arr = listeners.get(channel) || [];\n");
        output.push_str("      for (const cb of arr) {\n");
        output.push_str("        try {\n");
        output.push_str("          cb(payload);\n");
        output.push_str("        } catch (e) {\n");
        output.push_str("          console.error(\"[host.emit] Error:\", e);\n");
        output.push_str("        }\n");
        output.push_str("      }\n");
        output.push_str("      // Also send to Deno backend\n");
        output.push_str("      sendViaIpc(JSON.stringify({ channel, payload }));\n");
        output.push_str("    },\n\n");

        output.push_str("    send(channel: string, payload?: unknown) {\n");
        output.push_str("      const msg = JSON.stringify({ channel, payload });\n");
        output.push_str("      sendViaIpc(msg);\n");
        output.push_str("    },\n");
        output.push_str("  };\n\n");

        // Renderer ready signal
        output.push_str("  // Signal to backend that renderer is ready to receive messages.\n");
        output.push_str("  // Use setTimeout(0) to ensure __host_dispatch is fully registered.\n");
        output.push_str("  setTimeout(() => {\n");
        output.push_str("    if (globalThis.ipc) {\n");
        output.push_str("      globalThis.ipc.postMessage(JSON.stringify({\n");
        output.push_str("        channel: \"__renderer_ready__\",\n");
        output.push_str("        payload: {}\n");
        output.push_str("      }));\n");
        output.push_str("    }\n");
        output.push_str("  }, 0);\n\n");

        // Console forwarder
        output.push_str("  // Built-in listener for __console__ channel - forwards Deno logs to browser DevTools\n");
        output.push_str("  globalThis.host.on(\"__console__\", (payload: unknown) => {\n");
        output.push_str("    const msg = payload as { level: string; message: string; fields?: Record<string, unknown> };\n");
        output.push_str("    const { level, message, fields } = msg;\n");
        output.push_str("    const args: unknown[] = [message];\n");
        output.push_str("    if (fields && Object.keys(fields).length > 0) {\n");
        output.push_str("      args.push(fields);\n");
        output.push_str("    }\n");
        output.push_str("    switch (level) {\n");
        output.push_str("      case \"trace\":\n");
        output.push_str("      case \"debug\":\n");
        output.push_str("        console.debug(...args);\n");
        output.push_str("        break;\n");
        output.push_str("      case \"info\":\n");
        output.push_str("        console.info(...args);\n");
        output.push_str("        break;\n");
        output.push_str("      case \"warn\":\n");
        output.push_str("      case \"warning\":\n");
        output.push_str("        console.warn(...args);\n");
        output.push_str("        break;\n");
        output.push_str("      case \"error\":\n");
        output.push_str("        console.error(...args);\n");
        output.push_str("        break;\n");
        output.push_str("      default:\n");
        output.push_str("        console.log(...args);\n");
        output.push_str("    }\n");
        output.push_str("  });\n\n");

        // HMR client
        if self.enable_hmr {
            output.push_str("  // HMR (Hot Module Replacement) client - connects to dev server for live reload\n");
            output.push_str("  // Only runs in dev mode (when app:// protocol is used and HMR server is available)\n");
            output.push_str("  if (location.protocol === \"app:\") {\n");
            output.push_str("    const HMR_PORT = 35729;\n");
            output.push_str("    const MAX_RECONNECT_ATTEMPTS = 5;\n");
            output.push_str("    const attemptRef = { current: 0 };\n");
            output.push_str(
                "    const socketRef: { current: WebSocket | null } = { current: null };\n\n",
            );

            output
                .push_str("    // Start HMR connection after a short delay to let the page load\n");
            output.push_str("    setTimeout(() => connectHMR(HMR_PORT, MAX_RECONNECT_ATTEMPTS, attemptRef, socketRef), 500);\n");
            output.push_str("  }\n");
        }

        output.push_str("})();\n");

        output
    }
}

impl Default for PreloadGenerator {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_basic_preload() {
        let gen = PreloadGenerator::new();
        let output = gen.generate();

        // Should contain essential parts
        assert!(output.contains("globalThis.host"));
        assert!(output.contains("__host_dispatch"));
        assert!(output.contains("HostBridge"));
        assert!(output.contains("connectHMR"));
    }

    #[test]
    fn test_generate_with_modules() {
        let module = WeldModule::host("fs").with_extensibility();
        let gen = PreloadGenerator::with_modules(vec![module]);
        let output = gen.generate();

        // Should contain extension metadata
        assert!(output.contains("_extensionMeta"));
        assert!(output.contains("\"fs\""));
    }

    #[test]
    fn test_disable_hmr() {
        let gen = PreloadGenerator::new().disable_hmr();
        let output = gen.generate();

        // Should not contain HMR code
        assert!(!output.contains("connectHMR"));
    }
}
