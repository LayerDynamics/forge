//! TypeScript declaration file (.d.ts) generator
//!
//! Generates TypeScript declaration files for ambient module declarations
//! (e.g., `declare module "runtime:fs" { ... }`).

use crate::ir::{OpSymbol, WeldEnum, WeldModule, WeldStruct, WeldType};

/// Generator for TypeScript .d.ts declaration files
pub struct DtsGenerator<'a> {
    module: &'a WeldModule,
}

impl<'a> DtsGenerator<'a> {
    /// Create a new .d.ts generator for a module
    pub fn new(module: &'a WeldModule) -> Self {
        Self { module }
    }

    /// Generate the complete .d.ts file content
    pub fn generate(&self) -> String {
        let mut output = String::new();

        // Header comment
        output.push_str(&format!(
            "// Auto-generated TypeScript definitions for {} module\n",
            self.module.specifier
        ));
        output.push_str("// Generated by forge-weld - do not edit manually\n\n");

        // Module declaration
        output.push_str(&format!(
            "declare module \"{}\" {{\n",
            self.module.specifier
        ));

        // Add module doc if present
        if let Some(ref doc) = self.module.doc {
            output.push_str("  /**\n");
            for line in doc.lines() {
                output.push_str(&format!("   * {}\n", line));
            }
            output.push_str("   */\n\n");
        }

        // Generate interface declarations for structs
        for s in &self.module.structs {
            output.push_str(&self.generate_interface(s, 2));
            output.push('\n');
        }

        // Generate enum/type declarations
        for e in &self.module.enums {
            output.push_str(&self.generate_enum(e, 2));
            output.push('\n');
        }

        // Generate function declarations for ops
        for op in &self.module.ops {
            output.push_str(&self.generate_function_declaration(op, 2));
            output.push('\n');
        }

        output.push_str("}\n");
        output
    }

    /// Generate a TypeScript interface declaration with indentation
    fn generate_interface(&self, s: &WeldStruct, indent: usize) -> String {
        let mut output = String::new();
        let spaces = " ".repeat(indent);

        // Doc comment
        if let Some(ref doc) = s.doc {
            output.push_str(&format!("{}/**\n", spaces));
            for line in doc.lines() {
                output.push_str(&format!("{} * {}\n", spaces, line));
            }
            output.push_str(&format!("{} */\n", spaces));
        }

        // Exported interface with optional type parameters
        if s.type_params.is_empty() {
            output.push_str(&format!("{}export interface {} {{\n", spaces, s.ts_name));
        } else {
            output.push_str(&format!(
                "{}export interface {}<{}> {{\n",
                spaces,
                s.ts_name,
                s.type_params.join(", ")
            ));
        }

        // Fields
        for field in &s.fields {
            // Field doc comment
            if let Some(ref doc) = field.doc {
                output.push_str(&format!("{}  /** {} */\n", spaces, doc));
            }

            let readonly_prefix = if field.readonly { "readonly " } else { "" };
            let optional_suffix = if field.optional { "?" } else { "" };

            output.push_str(&format!(
                "{}  {}{}{}: {};\n",
                spaces,
                readonly_prefix,
                field.ts_name,
                optional_suffix,
                field.ty.to_typescript()
            ));
        }

        output.push_str(&format!("{}}}\n", spaces));
        output
    }

    /// Generate a TypeScript enum/type declaration with indentation
    fn generate_enum(&self, e: &WeldEnum, indent: usize) -> String {
        let mut output = String::new();
        let spaces = " ".repeat(indent);

        // Doc comment
        if let Some(ref doc) = e.doc {
            output.push_str(&format!("{}/**\n", spaces));
            for line in doc.lines() {
                output.push_str(&format!("{} * {}\n", spaces, line));
            }
            output.push_str(&format!("{} */\n", spaces));
        }

        // Check if it's a simple string enum (all unit variants - no data)
        let all_unit = e.variants.iter().all(|v| v.data.is_none());

        if all_unit {
            // Generate as string literal union type
            let variants: Vec<String> = e
                .variants
                .iter()
                .map(|v| {
                    let value = v.value.as_ref().unwrap_or(&v.name);
                    format!("\"{}\"", value)
                })
                .collect();
            output.push_str(&format!(
                "{}export type {} = {};\n",
                spaces,
                e.ts_name,
                variants.join(" | ")
            ));
        } else {
            // Generate as discriminated union with interfaces
            let mut variant_types = Vec::new();

            for variant in &e.variants {
                let variant_type_name = format!("{}_{}", e.ts_name, variant.name);

                output.push_str(&format!(
                    "{}export interface {} {{\n",
                    spaces, variant_type_name
                ));
                output.push_str(&format!("{}  type: \"{}\";\n", spaces, variant.name));

                if let Some(ref data) = variant.data {
                    output.push_str(&format!("{}  data: {};\n", spaces, data.to_typescript()));
                }

                output.push_str(&format!("{}}}\n\n", spaces));
                variant_types.push(variant_type_name);
            }

            output.push_str(&format!(
                "{}export type {} = {};\n",
                spaces,
                e.ts_name,
                variant_types.join(" | ")
            ));
        }

        output
    }

    /// Generate a function declaration with JSDoc
    fn generate_function_declaration(&self, op: &OpSymbol, indent: usize) -> String {
        let mut output = String::new();
        let spaces = " ".repeat(indent);

        // JSDoc comment
        output.push_str(&format!("{}/**\n", spaces));
        if let Some(ref doc) = op.doc {
            for line in doc.lines() {
                output.push_str(&format!("{} * {}\n", spaces, line));
            }
        }

        // Add @param tags
        for param in op.visible_params() {
            if let Some(ref doc) = param.doc {
                output.push_str(&format!(
                    "{} * @param {} - {}\n",
                    spaces, param.ts_name, doc
                ));
            } else {
                output.push_str(&format!("{} * @param {}\n", spaces, param.ts_name));
            }
        }

        output.push_str(&format!("{} */\n", spaces));

        // Build parameter list
        let visible_params: Vec<_> = op.visible_params().collect();
        let params: Vec<String> = visible_params
            .iter()
            .map(|p| {
                let optional_mark = if p.optional { "?" } else { "" };
                format!("{}{}: {}", p.ts_name, optional_mark, p.ty.to_typescript())
            })
            .collect();

        // Determine return type
        let return_type = op.ts_return_type();

        // Generate function declaration
        output.push_str(&format!(
            "{}export function {}({}): {};\n",
            spaces,
            op.ts_name,
            params.join(", "),
            return_type
        ));

        output
    }

    /// Generate type alias exports
    pub fn generate_type_exports(&self, aliases: &[(String, WeldType)]) -> String {
        let mut output = String::new();

        for (name, ty) in aliases {
            output.push_str(&format!(
                "  export type {} = {};\n",
                name,
                ty.to_typescript()
            ));
        }

        output
    }

    /// Generate a callback type export
    pub fn generate_callback_type(
        &self,
        name: &str,
        params: &[(String, WeldType)],
        return_type: &WeldType,
        indent: usize,
    ) -> String {
        let spaces = " ".repeat(indent);
        let params_str: Vec<String> = params
            .iter()
            .map(|(n, t)| format!("{}: {}", n, t.to_typescript()))
            .collect();

        format!(
            "{}export type {} = ({}) => {};\n",
            spaces,
            name,
            params_str.join(", "),
            return_type.to_typescript()
        )
    }
}

/// Builder for creating custom .d.ts files with sections
pub struct DtsBuilder {
    module_specifier: String,
    sections: Vec<DtsSection>,
}

/// A section in a .d.ts file (for organizing types/functions)
pub struct DtsSection {
    pub name: String,
    pub content: String,
}

impl DtsBuilder {
    /// Create a new .d.ts builder
    pub fn new(module_specifier: impl Into<String>) -> Self {
        Self {
            module_specifier: module_specifier.into(),
            sections: Vec::new(),
        }
    }

    /// Add a section with a header comment
    pub fn section(mut self, name: impl Into<String>, content: impl Into<String>) -> Self {
        self.sections.push(DtsSection {
            name: name.into(),
            content: content.into(),
        });
        self
    }

    /// Build the final .d.ts content
    pub fn build(self) -> String {
        let mut output = String::new();

        output.push_str(&format!(
            "// Auto-generated TypeScript definitions for {} module\n",
            self.module_specifier
        ));
        output.push_str("// Generated by forge-weld - do not edit manually\n\n");

        output.push_str(&format!(
            "declare module \"{}\" {{\n",
            self.module_specifier
        ));

        for section in self.sections {
            // Section header
            output.push_str(&format!(
                "  // {}\n  // {}\n\n",
                "=".repeat(76),
                section.name
            ));
            output.push_str(&format!("  // {}\n\n", "=".repeat(76)));

            // Section content (already indented)
            output.push_str(&section.content);
            output.push('\n');
        }

        output.push_str("}\n");
        output
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir::{OpParam, StructField, WeldPrimitive};

    #[test]
    fn test_generate_dts() {
        let module = WeldModule::host("fs")
            .with_doc("Filesystem operations")
            .struct_def(
                WeldStruct::new("FileStat")
                    .field(StructField::new("isFile", WeldType::bool()))
                    .field(StructField::new(
                        "size",
                        WeldType::Primitive(WeldPrimitive::U64),
                    )),
            )
            .op(OpSymbol::from_rust_name("op_fs_read_text")
                .async_op()
                .ts_name("readTextFile")
                .param(OpParam::new("path", WeldType::string()))
                .returns(WeldType::result(
                    WeldType::string(),
                    WeldType::struct_ref("FsError"),
                ))
                .with_doc("Read a file as UTF-8 text"));

        let gen = DtsGenerator::new(&module);
        let output = gen.generate();

        assert!(output.contains("declare module \"runtime:fs\""));
        assert!(output.contains("export interface FileStat"));
        assert!(output.contains("export function readTextFile"));
    }

    #[test]
    fn test_dts_builder() {
        let dts = DtsBuilder::new("runtime:test")
            .section("Types", "  export interface Foo { bar: string; }\n")
            .section("Functions", "  export function test(): void;\n")
            .build();

        assert!(dts.contains("declare module \"runtime:test\""));
        assert!(dts.contains("Types"));
        assert!(dts.contains("Functions"));
        assert!(dts.contains("export interface Foo"));
    }
}
