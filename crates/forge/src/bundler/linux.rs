//! Linux AppImage and tarball packaging backend
//!
//! Creates:
//! - AppImage via appimagetool (if available)
//! - AppImage via mksquashfs + runtime (fallback)
//! - Portable .tar.gz archive (final fallback)
//!
//! Follows freedesktop.org standards for .desktop files and icon placement.

use anyhow::{Context, Result, bail};
use std::fs::{self, File};
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::Command;

use super::{AppManifest, IconProcessor, build_embedded_binary, sanitize_name};

/// Linux bundler
pub struct LinuxBundler<'a> {
    app_dir: &'a Path,
    dist_dir: &'a Path,
    output_dir: &'a Path,
    manifest: &'a AppManifest,
}

impl<'a> LinuxBundler<'a> {
    pub fn new(
        app_dir: &'a Path,
        dist_dir: &'a Path,
        output_dir: &'a Path,
        manifest: &'a AppManifest,
    ) -> Self {
        Self {
            app_dir,
            dist_dir,
            output_dir,
            manifest,
        }
    }

    /// Execute Linux bundling pipeline
    pub fn bundle(&self) -> Result<PathBuf> {
        println!("Creating Linux package...");

        let linux_config = self.manifest.bundle.linux.as_ref();
        let format = linux_config
            .map(|c| c.format_or_default())
            .unwrap_or_else(|| "appimage".to_string());

        // 1. Create AppDir structure
        let appdir_path = self.create_appdir()?;

        // 2. Create final package based on format
        let result = match format.as_str() {
            "appimage" => self.create_appimage(&appdir_path),
            "tarball" | "tar.gz" => self.create_tarball(&appdir_path),
            _ => bail!("Unknown Linux bundle format: {}", format),
        };

        // Keep AppDir for debugging, but could clean up:
        // fs::remove_dir_all(&appdir_path)?;

        result
    }

    /// Create AppDir structure
    fn create_appdir(&self) -> Result<PathBuf> {
        let app_name = &self.manifest.app.name;
        let exec_name = sanitize_name(app_name);

        let appdir_name = format!("{}.AppDir", app_name.replace(' ', ""));
        let appdir_path = self.output_dir.join(&appdir_name);

        // Clean up existing AppDir
        if appdir_path.exists() {
            fs::remove_dir_all(&appdir_path)?;
        }

        // Create directory structure
        let dirs = [
            "",
            "usr/bin",
            "usr/lib",
            "usr/share/applications",
            "usr/share/icons/hicolor/256x256/apps",
        ];

        for dir in &dirs {
            fs::create_dir_all(appdir_path.join(dir))?;
        }

        println!("  Creating AppDir at {}", appdir_path.display());

        // 1. Build forge-host with embedded assets
        let binary_path = build_embedded_binary(self.dist_dir)?;

        // 2. Copy binary to usr/bin
        let bin_dest = appdir_path.join("usr/bin").join(&exec_name);
        fs::copy(&binary_path, &bin_dest)?;

        // Make binary executable
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(&bin_dest)?.permissions();
            perms.set_mode(0o755);
            fs::set_permissions(&bin_dest, perms)?;
        }

        // 3. Create AppRun script
        println!("  Creating AppRun script...");
        let apprun_content = self.generate_apprun_script(&exec_name);
        let apprun_path = appdir_path.join("AppRun");
        fs::write(&apprun_path, &apprun_content)?;

        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(&apprun_path)?.permissions();
            perms.set_mode(0o755);
            fs::set_permissions(&apprun_path, perms)?;
        }

        // 4. Create .desktop file
        println!("  Creating desktop entry...");
        let desktop_content = self.generate_desktop_file(&exec_name);
        let desktop_path = appdir_path.join(format!("{}.desktop", exec_name));
        fs::write(&desktop_path, &desktop_content)?;

        // Also copy to usr/share/applications
        fs::write(
            appdir_path.join("usr/share/applications").join(format!("{}.desktop", exec_name)),
            &desktop_content,
        )?;

        // 5. Handle icon
        println!("  Generating icons...");
        let icon_base = self.manifest.bundle.icon.as_deref();
        let icon_processor = IconProcessor::find_icon(self.app_dir, icon_base)?;
        icon_processor.place_linux_icons(&appdir_path, &exec_name)?;

        println!("  AppDir created successfully");
        Ok(appdir_path)
    }

    /// Generate AppRun script
    fn generate_apprun_script(&self, exec_name: &str) -> String {
        format!(
            r#"#!/bin/bash
# AppRun script for {exec_name}
# Generated by forge bundle

SELF=$(readlink -f "$0")
HERE=${{SELF%/*}}

# Set up library and data paths
export PATH="${{HERE}}/usr/bin/:${{HERE}}/usr/sbin/:${{HERE}}/bin/:${{HERE}}/sbin/${{PATH:+:$PATH}}"
export LD_LIBRARY_PATH="${{HERE}}/usr/lib/:${{HERE}}/usr/lib/x86_64-linux-gnu/:${{HERE}}/lib/:${{HERE}}/lib/x86_64-linux-gnu/${{LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}}"
export XDG_DATA_DIRS="${{HERE}}/usr/share/${{XDG_DATA_DIRS:+:$XDG_DATA_DIRS}}"

# Set app-specific variables
export APPDIR="${{HERE}}"
export APPIMAGE="${{APPIMAGE:-}}"

exec "${{HERE}}/usr/bin/{exec_name}" "$@"
"#,
            exec_name = exec_name
        )
    }

    /// Generate freedesktop.org desktop entry
    fn generate_desktop_file(&self, exec_name: &str) -> String {
        let app = &self.manifest.app;
        let linux_config = self.manifest.bundle.linux.as_ref();

        let categories = linux_config
            .map(|c| c.categories_or_default())
            .unwrap_or_else(|| vec!["Utility".to_string()])
            .join(";");

        let generic_name = linux_config
            .map(|c| c.generic_name_or_default(&app.name))
            .unwrap_or_else(|| app.name.clone());

        let comment = linux_config
            .map(|c| c.comment_or_default(&app.name))
            .unwrap_or_else(|| format!("{} application", app.name));

        let terminal = linux_config
            .and_then(|c| c.terminal)
            .unwrap_or(false);

        let mime_types = linux_config
            .and_then(|c| c.mime_types.as_ref())
            .map(|mimes| format!("MimeType={}\n", mimes.join(";")))
            .unwrap_or_default();

        format!(
            r#"[Desktop Entry]
Type=Application
Name={name}
GenericName={generic_name}
Comment={comment}
Exec={exec_name}
Icon={exec_name}
Categories={categories};
Terminal={terminal}
{mime_types}StartupWMClass={identifier}
"#,
            name = app.name,
            generic_name = generic_name,
            comment = comment,
            exec_name = exec_name,
            categories = categories,
            terminal = if terminal { "true" } else { "false" },
            mime_types = mime_types,
            identifier = app.identifier,
        )
    }

    /// Create AppImage using available tools
    fn create_appimage(&self, appdir_path: &Path) -> Result<PathBuf> {
        let app_name = &self.manifest.app.name;
        let version = &self.manifest.app.version;

        let appimage_name = format!(
            "{}-{}-x86_64.AppImage",
            app_name.replace(' ', ""),
            version
        );
        let appimage_path = self.output_dir.join(&appimage_name);

        // Try appimagetool first
        if let Some(tool) = find_appimagetool() {
            println!("  Found appimagetool at {}", tool.display());
            return self.create_with_appimagetool(&tool, appdir_path, &appimage_path);
        }

        // Try mksquashfs as fallback
        if let Some(mksquashfs) = find_mksquashfs() {
            println!("  Found mksquashfs, creating AppImage manually...");
            return self.create_with_mksquashfs(&mksquashfs, appdir_path, &appimage_path);
        }

        // Fall back to tarball
        println!("  Warning: Neither appimagetool nor mksquashfs found");
        println!("  Creating portable tarball instead...");
        self.create_tarball(appdir_path)
    }

    /// Create AppImage using appimagetool
    fn create_with_appimagetool(
        &self,
        tool: &Path,
        appdir_path: &Path,
        output_path: &Path,
    ) -> Result<PathBuf> {
        println!("  Creating AppImage with appimagetool...");

        // Remove existing AppImage
        if output_path.exists() {
            fs::remove_file(output_path)?;
        }

        let status = Command::new(tool)
            .arg(appdir_path)
            .arg(output_path)
            .env("ARCH", std::env::consts::ARCH)
            .status()
            .context("Failed to run appimagetool")?;

        if !status.success() {
            bail!("appimagetool failed with status: {}", status);
        }

        println!("\n  AppImage created: {}", output_path.display());
        Ok(output_path.to_path_buf())
    }

    /// Create AppImage manually using mksquashfs
    fn create_with_mksquashfs(
        &self,
        mksquashfs: &Path,
        appdir_path: &Path,
        output_path: &Path,
    ) -> Result<PathBuf> {
        println!("  Creating AppImage with mksquashfs...");

        // Download/cache AppImage runtime
        let runtime_path = ensure_appimage_runtime()?;

        // Create squashfs image
        let squashfs_path = output_path.with_extension("squashfs");

        let squash_status = Command::new(mksquashfs)
            .args([
                &appdir_path.display().to_string(),
                &squashfs_path.display().to_string(),
                "-root-owned",
                "-noappend",
                "-comp", "gzip",
                "-b", "1M",
                "-Xcompression-level", "9",
            ])
            .status()
            .context("Failed to run mksquashfs")?;

        if !squash_status.success() {
            bail!("mksquashfs failed with status: {}", squash_status);
        }

        // Concatenate runtime + squashfs
        let runtime_data = fs::read(&runtime_path)?;
        let squashfs_data = fs::read(&squashfs_path)?;

        let mut output_file = File::create(output_path)?;
        output_file.write_all(&runtime_data)?;
        output_file.write_all(&squashfs_data)?;

        // Clean up squashfs
        let _ = fs::remove_file(&squashfs_path);

        // Make executable
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(output_path)?.permissions();
            perms.set_mode(0o755);
            fs::set_permissions(output_path, perms)?;
        }

        println!("\n  AppImage created: {}", output_path.display());
        Ok(output_path.to_path_buf())
    }

    /// Create portable tarball archive
    fn create_tarball(&self, appdir_path: &Path) -> Result<PathBuf> {
        let app_name = &self.manifest.app.name;
        let version = &self.manifest.app.version;

        let tarball_name = format!(
            "{}-{}-linux-x86_64.tar.gz",
            sanitize_name(app_name),
            version
        );
        let tarball_path = self.output_dir.join(&tarball_name);

        println!("  Creating portable tarball...");

        let parent_dir = appdir_path.parent().unwrap();
        let appdir_name = appdir_path.file_name().unwrap();

        let status = Command::new("tar")
            .args([
                "-czf",
                &tarball_path.display().to_string(),
                "-C",
                &parent_dir.display().to_string(),
                &appdir_name.to_string_lossy(),
            ])
            .status()
            .context("Failed to create tarball")?;

        if !status.success() {
            bail!("tar failed with status: {}", status);
        }

        println!("\n  Tarball created: {}", tarball_path.display());
        Ok(tarball_path)
    }
}

/// Find appimagetool in common locations
fn find_appimagetool() -> Option<PathBuf> {
    let candidates = [
        "appimagetool",
        "appimagetool-x86_64.AppImage",
        "/usr/local/bin/appimagetool",
        "/opt/appimagetool/appimagetool",
    ];

    for candidate in &candidates {
        // Check PATH
        if let Ok(output) = Command::new("which").arg(candidate).output() {
            if output.status.success() {
                let path = String::from_utf8_lossy(&output.stdout).trim().to_string();
                return Some(PathBuf::from(path));
            }
        }

        // Check direct path
        let path = PathBuf::from(candidate);
        if path.exists() {
            return Some(path);
        }
    }

    None
}

/// Find mksquashfs
fn find_mksquashfs() -> Option<PathBuf> {
    if let Ok(output) = Command::new("which").arg("mksquashfs").output() {
        if output.status.success() {
            let path = String::from_utf8_lossy(&output.stdout).trim().to_string();
            return Some(PathBuf::from(path));
        }
    }
    None
}

/// Ensure AppImage runtime is available (download if needed)
fn ensure_appimage_runtime() -> Result<PathBuf> {
    let cache_dir = dirs::cache_dir()
        .unwrap_or_else(|| PathBuf::from("/tmp"))
        .join("forge/appimage");

    fs::create_dir_all(&cache_dir)?;

    let runtime_path = cache_dir.join("runtime-x86_64");

    if runtime_path.exists() {
        return Ok(runtime_path);
    }

    println!("    Downloading AppImage runtime...");

    let url = "https://github.com/AppImage/AppImageKit/releases/download/continuous/runtime-x86_64";

    let status = Command::new("curl")
        .args([
            "-L",
            "-o", &runtime_path.display().to_string(),
            url,
        ])
        .status()
        .context("Failed to download AppImage runtime")?;

    if !status.success() {
        // Try wget as fallback
        let wget_status = Command::new("wget")
            .args([
                "-O", &runtime_path.display().to_string(),
                url,
            ])
            .status();

        if wget_status.is_err() || !wget_status.unwrap().success() {
            bail!(
                "Failed to download AppImage runtime.\n\
                Install curl or wget, or manually download from:\n\
                {}\n\
                and place at: {}",
                url,
                runtime_path.display()
            );
        }
    }

    Ok(runtime_path)
}

/// Main bundle entry point
pub fn bundle(
    app_dir: &Path,
    dist_dir: &Path,
    output_dir: &Path,
    manifest: &AppManifest,
) -> Result<PathBuf> {
    let bundler = LinuxBundler::new(app_dir, dist_dir, output_dir, manifest);
    bundler.bundle()
}

#[cfg(test)]
mod tests {
    #[allow(unused_imports)]
    use super::*;

    #[test]
    fn test_desktop_file_generation() {
        // Basic test for desktop file content
        let exec_name = "myapp";
        let expected_contains = "[Desktop Entry]";
        let desktop = format!(
            "[Desktop Entry]\nType=Application\nName=MyApp\nExec={}\n",
            exec_name
        );
        assert!(desktop.contains(expected_contains));
    }

    #[test]
    fn test_sanitize_name_for_linux() {
        // Use sanitize_name from super::* to ensure proper name handling
        let name = sanitize_name("My App Name");
        assert_eq!(name, "my-app-name");

        let special = sanitize_name("App@#$%Special");
        assert_eq!(special, "app-special");

        let spaces = sanitize_name("  Multiple   Spaces  ");
        assert_eq!(spaces, "multiple-spaces");
    }
}
