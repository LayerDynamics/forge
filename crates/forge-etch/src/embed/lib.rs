//! Asset embedding for forge-etch standalone documentation.
//!
//! This module provides utilities for embedding CSS, JavaScript, and other assets
//! directly into HTML documentation files, enabling single-file output that works
//! without external dependencies.
//!
//! # Features
//!
//! - **Inline CSS**: Embed styles directly in `<style>` tags
//! - **Inline JavaScript**: Embed search and interaction scripts
//! - **Single-file output**: Generate self-contained HTML documentation
//!
//! # Example
//!
//! ```
//! use forge_etch::embed::{EmbedConfig, embed_in_html};
//!
//! let config = EmbedConfig {
//!     include_css: true,
//!     include_js: true,
//!     inline_assets: true,
//!     include_syntax_highlighting: false,
//!     include_copy_button: true,
//! };
//!
//! let html = r#"<html><head><link rel="stylesheet" href="styles.css"></head><body></body></html>"#;
//! let standalone = embed_in_html(html, &config);
//! // CSS is now inline in a <style> tag
//! ```

use std::collections::HashMap;

/// Configuration for embedded assets in documentation output.
///
/// Controls which assets are included and whether they should be inlined
/// directly into the HTML (for single-file output) or referenced externally.
#[derive(Debug, Clone, Default)]
pub struct EmbedConfig {
    /// Include CSS stylesheet in output.
    pub include_css: bool,

    /// Include JavaScript for search and interactivity.
    pub include_js: bool,

    /// Inline assets directly in HTML instead of external files.
    ///
    /// When true:
    /// - `<link rel="stylesheet">` becomes `<style>...</style>`
    /// - Scripts are embedded in `<script>` tags
    ///
    /// When false:
    /// - Assets remain as external file references
    pub inline_assets: bool,

    /// Include syntax highlighting support.
    pub include_syntax_highlighting: bool,

    /// Include copy-to-clipboard functionality for code blocks.
    pub include_copy_button: bool,
}

impl EmbedConfig {
    /// Create a new EmbedConfig with default settings (all disabled).
    pub fn new() -> Self {
        Self::default()
    }

    /// Create a config for standalone single-file output.
    ///
    /// Enables CSS, JS, and inlining for self-contained HTML.
    pub fn standalone() -> Self {
        Self {
            include_css: true,
            include_js: true,
            inline_assets: true,
            include_syntax_highlighting: true,
            include_copy_button: true,
        }
    }

    /// Create a config for external assets (multi-file output).
    pub fn external() -> Self {
        Self {
            include_css: true,
            include_js: true,
            inline_assets: false,
            include_syntax_highlighting: true,
            include_copy_button: true,
        }
    }

    /// Builder method to enable CSS inclusion.
    pub fn with_css(mut self) -> Self {
        self.include_css = true;
        self
    }

    /// Builder method to enable JavaScript inclusion.
    pub fn with_js(mut self) -> Self {
        self.include_js = true;
        self
    }

    /// Builder method to enable asset inlining.
    pub fn with_inlining(mut self) -> Self {
        self.inline_assets = true;
        self
    }
}

/// Default CSS stylesheet for documentation.
///
/// This is the same CSS generated by the HTML generator, provided here
/// for embedding in standalone documentation files.
pub const DEFAULT_CSS: &str = r##"/* forge-etch generated documentation styles */
:root {
    --bg-color: #ffffff;
    --text-color: #24292e;
    --code-bg: #f6f8fa;
    --border-color: #e1e4e8;
    --link-color: #0366d6;
    --heading-color: #24292e;
    --accent-color: #6f42c1;
    --success-color: #28a745;
    --warning-color: #ffd33d;
}

@media (prefers-color-scheme: dark) {
    :root {
        --bg-color: #0d1117;
        --text-color: #c9d1d9;
        --code-bg: #161b22;
        --border-color: #30363d;
        --link-color: #58a6ff;
        --heading-color: #f0f6fc;
        --accent-color: #a371f7;
        --success-color: #3fb950;
        --warning-color: #d29922;
    }
}

* {
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    line-height: 1.6;
    color: var(--text-color);
    background-color: var(--bg-color);
    max-width: 900px;
    margin: 0 auto;
    padding: 2rem;
}

h1, h2, h3, h4 {
    color: var(--heading-color);
    margin-top: 1.5em;
    margin-bottom: 0.5em;
}

h1 { font-size: 2rem; border-bottom: 1px solid var(--border-color); padding-bottom: 0.3em; }
h2 { font-size: 1.5rem; }
h3 { font-size: 1.25rem; }

a {
    color: var(--link-color);
    text-decoration: none;
}

a:hover {
    text-decoration: underline;
}

code {
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
    font-size: 0.875em;
    background-color: var(--code-bg);
    padding: 0.2em 0.4em;
    border-radius: 3px;
}

pre {
    background-color: var(--code-bg);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 1rem;
    overflow-x: auto;
    position: relative;
}

pre code {
    background: none;
    padding: 0;
}

.description {
    font-size: 1.1rem;
    color: var(--text-color);
    margin-bottom: 1.5rem;
}

.breadcrumb {
    font-size: 0.9rem;
    color: var(--text-color);
    margin-bottom: 1rem;
}

.toc {
    background-color: var(--code-bg);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 1rem;
    margin-bottom: 2rem;
}

.toc h2 {
    margin-top: 0;
    font-size: 1rem;
}

.toc ul {
    margin: 0;
    padding-left: 1.5rem;
}

.toc li {
    margin: 0.25rem 0;
}

.overview-list {
    list-style: none;
    padding: 0;
}

.overview-list li {
    padding: 0.5rem 0;
    border-bottom: 1px solid var(--border-color);
}

.symbol {
    margin-bottom: 2rem;
}

.signature {
    margin: 1rem 0;
}

.params {
    width: 100%;
    border-collapse: collapse;
    margin: 1rem 0;
}

.params th,
.params td {
    border: 1px solid var(--border-color);
    padding: 0.5rem;
    text-align: left;
}

.params th {
    background-color: var(--code-bg);
}

.doc {
    margin: 1rem 0;
}

.example {
    margin: 1rem 0;
}

hr {
    border: none;
    border-top: 1px solid var(--border-color);
    margin: 2rem 0;
}

footer {
    margin-top: 3rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border-color);
    font-size: 0.8rem;
    color: var(--text-color);
    opacity: 0.7;
}

/* Search box */
.search-container {
    margin-bottom: 1.5rem;
}

.search-input {
    width: 100%;
    padding: 0.75rem 1rem;
    font-size: 1rem;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    background-color: var(--bg-color);
    color: var(--text-color);
}

.search-input:focus {
    outline: none;
    border-color: var(--link-color);
    box-shadow: 0 0 0 3px rgba(3, 102, 214, 0.1);
}

.search-results {
    margin-top: 0.5rem;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    max-height: 300px;
    overflow-y: auto;
    display: none;
}

.search-results.active {
    display: block;
}

.search-result-item {
    padding: 0.5rem 1rem;
    cursor: pointer;
    border-bottom: 1px solid var(--border-color);
}

.search-result-item:last-child {
    border-bottom: none;
}

.search-result-item:hover {
    background-color: var(--code-bg);
}

/* Copy button for code blocks */
.copy-button {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
    padding: 0.25rem 0.5rem;
    font-size: 0.75rem;
    background-color: var(--border-color);
    border: none;
    border-radius: 3px;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.2s;
}

pre:hover .copy-button {
    opacity: 1;
}

.copy-button:hover {
    background-color: var(--link-color);
    color: white;
}

.copy-button.copied {
    background-color: var(--success-color);
    color: white;
}

/* Tag badges */
.tag {
    display: inline-block;
    padding: 0.125rem 0.5rem;
    font-size: 0.75rem;
    border-radius: 1rem;
    margin-right: 0.25rem;
}

.tag-async {
    background-color: var(--accent-color);
    color: white;
}

.tag-deprecated {
    background-color: var(--warning-color);
    color: black;
}

.tag-experimental {
    background-color: var(--border-color);
    color: var(--text-color);
}
"##;

/// JavaScript for search functionality.
///
/// Provides client-side search through documentation symbols.
pub const SEARCH_JS: &str = r##"// forge-etch documentation search
(function() {
    'use strict';

    // Build search index from page content
    function buildSearchIndex() {
        const index = [];
        const symbols = document.querySelectorAll('.symbol[id]');

        symbols.forEach(symbol => {
            const id = symbol.id;
            const heading = symbol.querySelector('h2, h3');
            const name = heading ? heading.textContent.trim() : id;
            const description = symbol.querySelector('.description');
            const desc = description ? description.textContent.trim() : '';

            index.push({
                id: id,
                name: name,
                description: desc,
                element: symbol
            });
        });

        return index;
    }

    // Fuzzy search matching
    function fuzzyMatch(needle, haystack) {
        needle = needle.toLowerCase();
        haystack = haystack.toLowerCase();

        if (haystack.includes(needle)) {
            return true;
        }

        // Simple fuzzy: check if all chars appear in order
        let j = 0;
        for (let i = 0; i < haystack.length && j < needle.length; i++) {
            if (haystack[i] === needle[j]) {
                j++;
            }
        }
        return j === needle.length;
    }

    // Initialize search
    function initSearch() {
        const searchInput = document.getElementById('search');
        const resultsContainer = document.getElementById('search-results');

        if (!searchInput || !resultsContainer) {
            return;
        }

        const index = buildSearchIndex();

        searchInput.addEventListener('input', function() {
            const query = this.value.trim();

            if (query.length < 2) {
                resultsContainer.classList.remove('active');
                resultsContainer.innerHTML = '';
                return;
            }

            const results = index.filter(item =>
                fuzzyMatch(query, item.name) || fuzzyMatch(query, item.description)
            ).slice(0, 10);

            if (results.length === 0) {
                resultsContainer.innerHTML = '<div class="search-result-item">No results found</div>';
            } else {
                resultsContainer.innerHTML = results.map(item =>
                    `<div class="search-result-item" data-target="${item.id}">
                        <strong>${escapeHtml(item.name)}</strong>
                        ${item.description ? `<br><small>${escapeHtml(item.description.substring(0, 100))}...</small>` : ''}
                    </div>`
                ).join('');
            }

            resultsContainer.classList.add('active');
        });

        resultsContainer.addEventListener('click', function(e) {
            const item = e.target.closest('.search-result-item');
            if (item && item.dataset.target) {
                const target = document.getElementById(item.dataset.target);
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    resultsContainer.classList.remove('active');
                    searchInput.value = '';
                }
            }
        });

        // Close results on outside click
        document.addEventListener('click', function(e) {
            if (!searchInput.contains(e.target) && !resultsContainer.contains(e.target)) {
                resultsContainer.classList.remove('active');
            }
        });
    }

    // Escape HTML for safe insertion
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initSearch);
    } else {
        initSearch();
    }
})();
"##;

/// JavaScript for copy-to-clipboard functionality on code blocks.
pub const COPY_BUTTON_JS: &str = r##"// Copy button for code blocks
(function() {
    'use strict';

    function initCopyButtons() {
        const codeBlocks = document.querySelectorAll('pre code');

        codeBlocks.forEach(code => {
            const pre = code.parentElement;
            if (!pre || pre.querySelector('.copy-button')) {
                return;
            }

            const button = document.createElement('button');
            button.className = 'copy-button';
            button.textContent = 'Copy';
            button.setAttribute('aria-label', 'Copy code to clipboard');

            button.addEventListener('click', async function() {
                try {
                    await navigator.clipboard.writeText(code.textContent);
                    button.textContent = 'Copied!';
                    button.classList.add('copied');

                    setTimeout(() => {
                        button.textContent = 'Copy';
                        button.classList.remove('copied');
                    }, 2000);
                } catch (err) {
                    console.error('Failed to copy:', err);
                    button.textContent = 'Failed';
                }
            });

            pre.appendChild(button);
        });
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initCopyButtons);
    } else {
        initCopyButtons();
    }
})();
"##;

/// Available embedded assets.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum EmbeddedAsset {
    /// Main stylesheet
    StylesCss,
    /// Search functionality JavaScript
    SearchJs,
    /// Copy button JavaScript
    CopyButtonJs,
}

impl EmbeddedAsset {
    /// Get the filename for this asset.
    pub fn filename(&self) -> &'static str {
        match self {
            Self::StylesCss => "styles.css",
            Self::SearchJs => "search.js",
            Self::CopyButtonJs => "copy-button.js",
        }
    }

    /// Get the content of this asset.
    pub fn content(&self) -> &'static str {
        match self {
            Self::StylesCss => DEFAULT_CSS,
            Self::SearchJs => SEARCH_JS,
            Self::CopyButtonJs => COPY_BUTTON_JS,
        }
    }

    /// Get the MIME type for this asset.
    pub fn mime_type(&self) -> &'static str {
        match self {
            Self::StylesCss => "text/css",
            Self::SearchJs | Self::CopyButtonJs => "text/javascript",
        }
    }
}

/// Get an embedded asset by filename.
///
/// # Arguments
///
/// * `name` - The asset filename (e.g., "styles.css")
///
/// # Returns
///
/// The asset content if found, or `None` if not found.
///
/// # Example
///
/// ```
/// use forge_etch::embed::get_asset;
///
/// if let Some(css) = get_asset("styles.css") {
///     println!("CSS length: {} bytes", css.len());
/// }
/// ```
pub fn get_asset(name: &str) -> Option<&'static str> {
    match name {
        "styles.css" => Some(DEFAULT_CSS),
        "search.js" => Some(SEARCH_JS),
        "copy-button.js" => Some(COPY_BUTTON_JS),
        _ => None,
    }
}

/// List all available embedded asset filenames.
///
/// # Example
///
/// ```
/// use forge_etch::embed::list_assets;
///
/// for asset in list_assets() {
///     println!("Available: {}", asset);
/// }
/// ```
pub fn list_assets() -> &'static [&'static str] {
    &["styles.css", "search.js", "copy-button.js"]
}

/// Get all embedded assets as a map of filename to content.
pub fn all_assets() -> HashMap<&'static str, &'static str> {
    let mut map = HashMap::new();
    map.insert("styles.css", DEFAULT_CSS);
    map.insert("search.js", SEARCH_JS);
    map.insert("copy-button.js", COPY_BUTTON_JS);
    map
}

/// Embed assets inline in HTML content.
///
/// This transforms external asset references into inline content:
/// - `<link rel="stylesheet" href="styles.css">` becomes `<style>...</style>`
/// - External scripts become inline `<script>` tags
///
/// # Arguments
///
/// * `html` - The HTML content to transform
/// * `config` - Configuration controlling which assets to embed
///
/// # Returns
///
/// The transformed HTML with assets inlined.
///
/// # Example
///
/// ```
/// use forge_etch::embed::{EmbedConfig, embed_in_html};
///
/// let config = EmbedConfig::standalone();
/// let html = r#"<!DOCTYPE html>
/// <html>
/// <head>
///     <link rel="stylesheet" href="styles.css">
/// </head>
/// <body>
///     <h1>Documentation</h1>
/// </body>
/// </html>"#;
///
/// let standalone = embed_in_html(html, &config);
/// assert!(standalone.contains("<style>"));
/// assert!(!standalone.contains("href=\"styles.css\""));
/// ```
pub fn embed_in_html(html: &str, config: &EmbedConfig) -> String {
    let mut result = html.to_string();

    if config.include_css && config.inline_assets {
        // Replace external CSS link with inline style
        result = replace_css_link(&result, DEFAULT_CSS);
    }

    if config.include_js && config.inline_assets {
        // Add inline scripts before </body>
        let mut scripts = String::new();

        scripts.push_str("<script>\n");
        scripts.push_str(SEARCH_JS);
        scripts.push('\n');

        if config.include_copy_button {
            scripts.push_str(COPY_BUTTON_JS);
            scripts.push('\n');
        }

        scripts.push_str("</script>\n");

        result = result.replace("</body>", &format!("{}</body>", scripts));
    }

    result
}

/// Replace external CSS link tag with inline style.
fn replace_css_link(html: &str, css: &str) -> String {
    // Try different common patterns for stylesheet links
    let patterns = [
        r#"<link rel="stylesheet" href="styles.css">"#,
        r#"<link href="styles.css" rel="stylesheet">"#,
        r#"<link rel='stylesheet' href='styles.css'>"#,
        r#"<link href='styles.css' rel='stylesheet'>"#,
    ];

    let style_tag = format!("<style>\n{}\n</style>", css);

    for pattern in patterns {
        if html.contains(pattern) {
            return html.replace(pattern, &style_tag);
        }
    }

    // If no matching pattern found but we want CSS, try to insert in <head>
    if html.contains("</head>") && !html.contains("<style>") {
        return html.replace("</head>", &format!("{}\n</head>", style_tag));
    }

    html.to_string()
}

/// Generate a complete standalone HTML document with all assets embedded.
///
/// This is useful for generating single-file documentation that works
/// offline without any external dependencies.
///
/// # Arguments
///
/// * `title` - The document title
/// * `body` - The HTML body content
/// * `config` - Configuration controlling which assets to include
///
/// # Returns
///
/// A complete HTML document with embedded assets.
pub fn generate_standalone_html(title: &str, body: &str, config: &EmbedConfig) -> String {
    let mut head_content = String::new();
    let mut body_scripts = String::new();

    if config.include_css {
        head_content.push_str("<style>\n");
        head_content.push_str(DEFAULT_CSS);
        head_content.push_str("\n</style>\n");
    }

    if config.include_js {
        body_scripts.push_str("<script>\n");
        body_scripts.push_str(SEARCH_JS);
        body_scripts.push('\n');

        if config.include_copy_button {
            body_scripts.push_str(COPY_BUTTON_JS);
            body_scripts.push('\n');
        }

        body_scripts.push_str("</script>\n");
    }

    format!(
        r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
{head_content}</head>
<body>
{body}
{body_scripts}</body>
</html>"#,
        title = html_escape::encode_text(title),
        head_content = head_content,
        body = body,
        body_scripts = body_scripts
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_embed_config_default() {
        let config = EmbedConfig::default();
        assert!(!config.include_css);
        assert!(!config.include_js);
        assert!(!config.inline_assets);
    }

    #[test]
    fn test_embed_config_standalone() {
        let config = EmbedConfig::standalone();
        assert!(config.include_css);
        assert!(config.include_js);
        assert!(config.inline_assets);
    }

    #[test]
    fn test_get_asset() {
        assert!(get_asset("styles.css").is_some());
        assert!(get_asset("search.js").is_some());
        assert!(get_asset("copy-button.js").is_some());
        assert!(get_asset("nonexistent.js").is_none());
    }

    #[test]
    fn test_list_assets() {
        let assets = list_assets();
        assert!(assets.contains(&"styles.css"));
        assert!(assets.contains(&"search.js"));
        assert!(assets.contains(&"copy-button.js"));
    }

    #[test]
    fn test_embedded_asset_enum() {
        assert_eq!(EmbeddedAsset::StylesCss.filename(), "styles.css");
        assert_eq!(EmbeddedAsset::StylesCss.mime_type(), "text/css");
        assert_eq!(EmbeddedAsset::SearchJs.mime_type(), "text/javascript");
    }

    #[test]
    fn test_embed_in_html_css() {
        let config = EmbedConfig::standalone();
        let html =
            r#"<html><head><link rel="stylesheet" href="styles.css"></head><body></body></html>"#;
        let result = embed_in_html(html, &config);

        assert!(result.contains("<style>"));
        assert!(!result.contains(r#"href="styles.css""#));
        assert!(result.contains("--bg-color"));
    }

    #[test]
    fn test_embed_in_html_js() {
        let config = EmbedConfig::standalone();
        let html = r#"<html><head></head><body><h1>Test</h1></body></html>"#;
        let result = embed_in_html(html, &config);

        assert!(result.contains("<script>"));
        assert!(result.contains("buildSearchIndex"));
        assert!(result.contains("initCopyButtons"));
    }

    #[test]
    fn test_generate_standalone_html() {
        let config = EmbedConfig::standalone();
        let html = generate_standalone_html("Test Doc", "<h1>Hello</h1>", &config);

        assert!(html.contains("<!DOCTYPE html>"));
        assert!(html.contains("<title>Test Doc</title>"));
        assert!(html.contains("<h1>Hello</h1>"));
        assert!(html.contains("<style>"));
        assert!(html.contains("<script>"));
    }

    #[test]
    fn test_replace_css_link_various_formats() {
        let css = "body { color: red; }";

        // Double quotes, rel first
        let html1 = r#"<link rel="stylesheet" href="styles.css">"#;
        assert!(replace_css_link(html1, css).contains("<style>"));

        // Double quotes, href first
        let html2 = r#"<link href="styles.css" rel="stylesheet">"#;
        assert!(replace_css_link(html2, css).contains("<style>"));

        // Single quotes
        let html3 = r#"<link rel='stylesheet' href='styles.css'>"#;
        assert!(replace_css_link(html3, css).contains("<style>"));
    }
}
